const Nk = ({className: t})=>x.jsxs("div", {
    className: Mt("text-center", t),
    children: [x.jsxs("h1", {
        className: "font-orbitron text-4xl md:text-6xl font-black tracking-wider animate-float",
        children: [x.jsx("span", {
            className: "text-gradient glow-text",
            children: "BIGBULL"
        }), x.jsx("br", {}), x.jsx("span", {
            className: "text-neon-pink animate-pulse-glow",
            children: "X ZESTY"
        }), x.jsx("br", {}), x.jsx("span", {
            className: "text-neon-purple glow-text",
            children: "CHEATS"
        })]
    }), x.jsx("div", {
        className: "mt-4 h-1 w-48 mx-auto bg-gradient-to-r from-transparent via-neon-cyan to-transparent animate-shimmer"
    })]
})
  , Ik = ({className: t})=>x.jsxs("div", {
    className: Mt("flex flex-col sm:flex-row gap-4 justify-center items-center", t),
    children: [x.jsxs("a", {
        href: "https://t.me/mr_panel_live",
        target: "_blank",
        rel: "noopener noreferrer",
        className: "flex items-center gap-3 px-6 py-3 rounded-xl bg-gradient-to-r from-[#0088cc]/20 to-[#0088cc]/10 border border-[#0088cc]/50 hover:border-[#0088cc] hover:shadow-[0_0_20px_#0088cc50] transition-all duration-300 group",
        children: [x.jsx("svg", {
            className: "w-6 h-6 text-[#0088cc] group-hover:scale-110 transition-transform",
            viewBox: "0 0 24 24",
            fill: "currentColor",
            children: x.jsx("path", {
                d: "M11.944 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0a12 12 0 0 0-.056 0zm4.962 7.224c.1-.002.321.023.465.14a.506.506 0 0 1 .171.325c.016.093.036.306.02.472-.18 1.898-.962 6.502-1.36 8.627-.168.9-.499 1.201-.82 1.23-.696.065-1.225-.46-1.9-.902-1.056-.693-1.653-1.124-2.678-1.8-1.185-.78-.417-1.21.258-1.91.177-.184 3.247-2.977 3.307-3.23.007-.032.014-.15-.056-.212s-.174-.041-.249-.024c-.106.024-1.793 1.14-5.061 3.345-.48.33-.913.49-1.302.48-.428-.008-1.252-.241-1.865-.44-.752-.245-1.349-.374-1.297-.789.027-.216.325-.437.893-.663 3.498-1.524 5.83-2.529 6.998-3.014 3.332-1.386 4.025-1.627 4.476-1.635z"
            })
        }), x.jsx("span", {
            className: "font-rajdhani font-semibold text-[#0088cc]",
            children: "Telegram Channel"
        })]
    }), x.jsxs("a", {
        href: "https://youtube.com/@mr_proxy_live?si=dLZUCTxFB5kCeoXK",
        target: "_blank",
        rel: "noopener noreferrer",
        className: "flex items-center gap-3 px-6 py-3 rounded-xl bg-gradient-to-r from-[#ff0000]/20 to-[#ff0000]/10 border border-[#ff0000]/50 hover:border-[#ff0000] hover:shadow-[0_0_20px_#ff000050] transition-all duration-300 group",
        children: [x.jsx("svg", {
            className: "w-6 h-6 text-[#ff0000] group-hover:scale-110 transition-transform",
            viewBox: "0 0 24 24",
            fill: "currentColor",
            children: x.jsx("path", {
                d: "M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"
            })
        }), x.jsx("span", {
            className: "font-rajdhani font-semibold text-[#ff0000]",
            children: "YouTube Channel"
        })]
    })]
})
  , $k = Cg("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-lg text-sm font-semibold ring-offset-background transition-all duration-300 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 font-rajdhani uppercase tracking-wider", {
    variants: {
        variant: {
            default: "bg-primary text-primary-foreground hover:bg-primary/90 hover:shadow-[0_0_20px_hsl(180_100%_50%/0.5)]",
            destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
            outline: "border border-primary/50 bg-transparent text-primary hover:bg-primary/10 hover:border-primary hover:shadow-[0_0_15px_hsl(180_100%_50%/0.3)]",
            secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80 hover:shadow-[0_0_20px_hsl(280_100%_60%/0.5)]",
            ghost: "hover:bg-accent hover:text-accent-foreground",
            link: "text-primary underline-offset-4 hover:underline",
            neon: "relative bg-gradient-to-r from-[hsl(180,100%,50%)] via-[hsl(280,100%,60%)] to-[hsl(320,100%,60%)] text-[hsl(240,20%,4%)] font-bold hover:shadow-[0_0_30px_hsl(180_100%_50%/0.6),0_0_60px_hsl(280_100%_60%/0.4)]",
            glow: "bg-card border border-primary/50 text-foreground hover:border-primary hover:shadow-[0_0_25px_hsl(180_100%_50%/0.5)] hover:text-primary"
        },
        size: {
            default: "h-10 px-4 py-2",
            sm: "h-9 rounded-md px-3",
            lg: "h-12 rounded-lg px-8 text-base",
            xl: "h-14 rounded-xl px-10 text-lg",
            icon: "h-10 w-10"
        }
    },
    defaultVariants: {
        variant: "default",
        size: "default"
    }
})
  , Vd = b.forwardRef(({className: t, variant: e, size: r, asChild: n=!1, ...s},i)=>{
    const o = n ? k_ : "button";
    return x.jsx(o, {
        className: Mt($k({
            variant: e,
            size: r,
            className: t
        })),
        ref: i,
        ...s
    })
}
);
Vd.displayName = "Button";
const vs = b.forwardRef(({className: t, type: e, ...r},n)=>x.jsx("input", {
    type: e,
    className: Mt("flex h-12 w-full rounded-lg border border-border/50 bg-input px-4 py-2 text-base font-rajdhani text-foreground placeholder:text-muted-foreground transition-all duration-300 focus:outline-none focus:border-primary focus:shadow-[0_0_15px_hsl(180_100%_50%/0.3)] disabled:cursor-not-allowed disabled:opacity-50", t),
    ref: n,
    ...r
}));
vs.displayName = "Input";
const Lk = ({onLogin: t})=>{
    const [e,r] = b.useState("")
      , [n,s] = b.useState("")
      , [i,o] = b.useState(!1)
      , a = async l=>{
        if (l.preventDefault(),
        !e.trim() || !n.trim()) {
            Or({
                title: "Error",
                description: "Please enter both ID and Password",
                variant: "destructive"
            });
            return
        }
        o(!0),
        setTimeout(()=>{
            o(!1),
            Or({
                title: "Login Successful! ðŸŽ®",
                description: "Welcome to ANANT EMOTE WEB"
            }),
            t()
        }
        , 1e3)
    }
    ;
    return x.jsxs("form", {
        onSubmit: a,
        className: "space-y-6",
        children: [x.jsxs("div", {
            className: "space-y-2",
            children: [x.jsx("label", {
                className: "block text-sm font-semibold text-neon-cyan uppercase tracking-wider",
                children: "User ID"
            }), x.jsx(vs, {
                type: "text",
                placeholder: "Enter your ID",
                value: e,
                onChange: l=>r(l.target.value),
                className: "bg-card/50"
            })]
        }), x.jsxs("div", {
            className: "space-y-2",
            children: [x.jsx("label", {
                className: "block text-sm font-semibold text-neon-purple uppercase tracking-wider",
                children: "Password"
            }), x.jsx(vs, {
                type: "password",
                placeholder: "Enter your Password",
                value: n,
                onChange: l=>s(l.target.value),
                className: "bg-card/50"
            })]
        }), x.jsx(Vd, {
            type: "submit",
            variant: "neon",
            size: "xl",
            className: "w-full",
            disabled: i,
            children: i ? x.jsxs("span", {
                className: "flex items-center gap-2",
                children: [x.jsxs("svg", {
                    className: "animate-spin h-5 w-5",
                    viewBox: "0 0 24 24",
                    children: [x.jsx("circle", {
                        className: "opacity-25",
                        cx: "12",
                        cy: "12",
                        r: "10",
                        stroke: "currentColor",
                        strokeWidth: "4",
                        fill: "none"
                    }), x.jsx("path", {
                        className: "opacity-75",
                        fill: "currentColor",
                        d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                    })]
                }), "Logging In..."]
            }) : "LOGIN"
        })]
    })
}
;
var yc = function(t, e) {
    return yc = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(r, n) {
        r.__proto__ = n
    }
    || function(r, n) {
        for (var s in n)
            Object.prototype.hasOwnProperty.call(n, s) && (r[s] = n[s])
    }
    ,
    yc(t, e)
};
function Rv(t, e) {
    if (typeof e != "function" && e !== null)
        throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    yc(t, e);
    function r() {
        this.constructor = t
    }
    t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype,
    new r)
}
var Ia = function() {
    return Ia = Object.assign || function(e) {
        for (var r, n = 1, s = arguments.length; n < s; n++) {
            r = arguments[n];
            for (var i in r)
                Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i])
        }
        return e
    }
    ,
    Ia.apply(this, arguments)
};
function Vs(t, e) {
    var r = {};
    for (var n in t)
        Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function")
        for (var s = 0, n = Object.getOwnPropertySymbols(t); s < n.length; s++)
            e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[s]) && (r[n[s]] = t[n[s]]);
    return r
}
function jv(t, e, r, n) {
    var s = arguments.length, i = s < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, r) : n, o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        i = Reflect.decorate(t, e, r, n);
    else
        for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) && (i = (s < 3 ? o(i) : s > 3 ? o(e, r, i) : o(e, r)) || i);
    return s > 3 && i && Object.defineProperty(e, r, i),
    i
}
function Av(t, e) {
    return function(r, n) {
        e(r, n, t)
    }
}
function Nv(t, e, r, n, s, i) {
    function o(g) {
        if (g !== void 0 && typeof g != "function")
            throw new TypeError("Function expected");
        return g
    }
    for (var a = n.kind, l = a === "getter" ? "get" : a === "setter" ? "set" : "value", u = !e && t ? n.static ? t : t.prototype : null, c = e || (u ? Object.getOwnPropertyDescriptor(u, n.name) : {}), h, f = !1, d = r.length - 1; d >= 0; d--) {
        var y = {};
        for (var m in n)
            y[m] = m === "access" ? {} : n[m];
        for (var m in n.access)
            y.access[m] = n.access[m];
        y.addInitializer = function(g) {
            if (f)
                throw new TypeError("Cannot add initializers after decoration has completed");
            i.push(o(g || null))
        }
        ;
        var w = (0,
        r[d])(a === "accessor" ? {
            get: c.get,
            set: c.set
        } : c[l], y);
        if (a === "accessor") {
            if (w === void 0)
                continue;
            if (w === null || typeof w != "object")
                throw new TypeError("Object expected");
            (h = o(w.get)) && (c.get = h),
            (h = o(w.set)) && (c.set = h),
            (h = o(w.init)) && s.unshift(h)
        } else
            (h = o(w)) && (a === "field" ? s.unshift(h) : c[l] = h)
    }
    u && Object.defineProperty(u, n.name, c),
    f = !0
}
function Iv(t, e, r) {
    for (var n = arguments.length > 2, s = 0; s < e.length; s++)
        r = n ? e[s].call(t, r) : e[s].call(t);
    return n ? r : void 0
}
function $v(t) {
    return typeof t == "symbol" ? t : "".concat(t)
}
function Lv(t, e, r) {
    return typeof e == "symbol" && (e = e.description ? "[".concat(e.description, "]") : ""),
    Object.defineProperty(t, "name", {
        configurable: !0,
        value: r ? "".concat(r, " ", e) : e
    })
}
function Uv(t, e) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
        return Reflect.metadata(t, e)
}
function U(t, e, r, n) {
    function s(i) {
        return i instanceof r ? i : new r(function(o) {
            o(i)
        }
        )
    }
    return new (r || (r = Promise))(function(i, o) {
        function a(c) {
            try {
                u(n.next(c))
            } catch (h) {
                o(h)
            }
        }
        function l(c) {
            try {
                u(n.throw(c))
            } catch (h) {
                o(h)
            }
        }
        function u(c) {
            c.done ? i(c.value) : s(c.value).then(a, l)
        }
        u((n = n.apply(t, e || [])).next())
    }
    )
}
function Dv(t, e) {
    var r = {
        label: 0,
        sent: function() {
            if (i[0] & 1)
                throw i[1];
            return i[1]
        },
        trys: [],
        ops: []
    }, n, s, i, o = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
    return o.next = a(0),
    o.throw = a(1),
    o.return = a(2),
    typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this
    }
    ),
    o;
    function a(u) {
        return function(c) {
            return l([u, c])
        }
    }
    function l(u) {
        if (n)
            throw new TypeError("Generator is already executing.");
        for (; o && (o = 0,
        u[0] && (r = 0)),
        r; )
            try {
                if (n = 1,
                s && (i = u[0] & 2 ? s.return : u[0] ? s.throw || ((i = s.return) && i.call(s),
                0) : s.next) && !(i = i.call(s, u[1])).done)
                    return i;
                switch (s = 0,
                i && (u = [u[0] & 2, i.value]),
                u[0]) {
                case 0:
                case 1:
                    i = u;
                    break;
                case 4:
                    return r.label++,
                    {
                        value: u[1],
                        done: !1
                    };
                case 5:
                    r.label++,
                    s = u[1],
                    u = [0];
                    continue;
                case 7:
                    u = r.ops.pop(),
                    r.trys.pop();
                    continue;
                default:
                    if (i = r.trys,
                    !(i = i.length > 0 && i[i.length - 1]) && (u[0] === 6 || u[0] === 2)) {
                        r = 0;
                        continue
                    }
                    if (u[0] === 3 && (!i || u[1] > i[0] && u[1] < i[3])) {
                        r.label = u[1];
                        break
                    }
                    if (u[0] === 6 && r.label < i[1]) {
                        r.label = i[1],
                        i = u;
                        break
                    }
                    if (i && r.label < i[2]) {
                        r.label = i[2],
                        r.ops.push(u);
                        break
                    }
                    i[2] && r.ops.pop(),
                    r.trys.pop();
                    continue
                }
                u = e.call(t, r)
            } catch (c) {
                u = [6, c],
                s = 0
            } finally {
                n = i = 0
            }
        if (u[0] & 5)
            throw u[1];
        return {
            value: u[0] ? u[1] : void 0,
            done: !0
        }
    }
}
var pl = Object.create ? function(t, e, r, n) {
    n === void 0 && (n = r);
    var s = Object.getOwnPropertyDescriptor(e, r);
    (!s || ("get"in s ? !e.__esModule : s.writable || s.configurable)) && (s = {
        enumerable: !0,
        get: function() {
            return e[r]
        }
    }),
    Object.defineProperty(t, n, s)
}
: function(t, e, r, n) {
    n === void 0 && (n = r),
    t[n] = e[r]
}
;
function Mv(t, e) {
    for (var r in t)
        r !== "default" && !Object.prototype.hasOwnProperty.call(e, r) && pl(e, t, r)
}
function $a(t) {
    var e = typeof Symbol == "function" && Symbol.iterator
      , r = e && t[e]
      , n = 0;
    if (r)
        return r.call(t);
    if (t && typeof t.length == "number")
        return {
            next: function() {
                return t && n >= t.length && (t = void 0),
                {
                    value: t && t[n++],
                    done: !t
                }
            }
        };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
}
function Wd(t, e) {
    var r = typeof Symbol == "function" && t[Symbol.iterator];
    if (!r)
        return t;
    var n = r.call(t), s, i = [], o;
    try {
        for (; (e === void 0 || e-- > 0) && !(s = n.next()).done; )
            i.push(s.value)
    } catch (a) {
        o = {
            error: a
        }
    } finally {
        try {
            s && !s.done && (r = n.return) && r.call(n)
        } finally {
            if (o)
                throw o.error
        }
    }
    return i
}
function Fv() {
    for (var t = [], e = 0; e < arguments.length; e++)
        t = t.concat(Wd(arguments[e]));
    return t
}
function Bv() {
    for (var t = 0, e = 0, r = arguments.length; e < r; e++)
        t += arguments[e].length;
    for (var n = Array(t), s = 0, e = 0; e < r; e++)
        for (var i = arguments[e], o = 0, a = i.length; o < a; o++,
        s++)
            n[s] = i[o];
    return n
}
function zv(t, e, r) {
    if (r || arguments.length === 2)
        for (var n = 0, s = e.length, i; n < s; n++)
            (i || !(n in e)) && (i || (i = Array.prototype.slice.call(e, 0, n)),
            i[n] = e[n]);
    return t.concat(i || Array.prototype.slice.call(e))
}
function Ls(t) {
    return this instanceof Ls ? (this.v = t,
    this) : new Ls(t)
}
function Vv(t, e, r) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var n = r.apply(t, e || []), s, i = [];
    return s = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype),
    a("next"),
    a("throw"),
    a("return", o),
    s[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    s;
    function o(d) {
        return function(y) {
            return Promise.resolve(y).then(d, h)
        }
    }
    function a(d, y) {
        n[d] && (s[d] = function(m) {
            return new Promise(function(w, g) {
                i.push([d, m, w, g]) > 1 || l(d, m)
            }
            )
        }
        ,
        y && (s[d] = y(s[d])))
    }
    function l(d, y) {
        try {
            u(n[d](y))
        } catch (m) {
            f(i[0][3], m)
        }
    }
    function u(d) {
        d.value instanceof Ls ? Promise.resolve(d.value.v).then(c, h) : f(i[0][2], d)
    }
    function c(d) {
        l("next", d)
    }
    function h(d) {
        l("throw", d)
    }
    function f(d, y) {
        d(y),
        i.shift(),
        i.length && l(i[0][0], i[0][1])
    }
}
function Wv(t) {
    var e, r;
    return e = {},
    n("next"),
    n("throw", function(s) {
        throw s
    }),
    n("return"),
    e[Symbol.iterator] = function() {
        return this
    }
    ,
    e;
    function n(s, i) {
        e[s] = t[s] ? function(o) {
            return (r = !r) ? {
                value: Ls(t[s](o)),
                done: !1
            } : i ? i(o) : o
        }
        : i
    }
}
function Hv(t) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = t[Symbol.asyncIterator], r;
    return e ? e.call(t) : (t = typeof $a == "function" ? $a(t) : t[Symbol.iterator](),
    r = {},
    n("next"),
    n("throw"),
    n("return"),
    r[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    r);
    function n(i) {
        r[i] = t[i] && function(o) {
            return new Promise(function(a, l) {
                o = t[i](o),
                s(a, l, o.done, o.value)
            }
            )
        }
    }
    function s(i, o, a, l) {
        Promise.resolve(l).then(function(u) {
            i({
                value: u,
                done: a
            })
        }, o)
    }
}
function qv(t, e) {
    return Object.defineProperty ? Object.defineProperty(t, "raw", {
        value: e
    }) : t.raw = e,
    t
}
var Uk = Object.create ? function(t, e) {
    Object.defineProperty(t, "default", {
        enumerable: !0,
        value: e
    })
}
: function(t, e) {
    t.default = e
}
  , wc = function(t) {
    return wc = Object.getOwnPropertyNames || function(e) {
        var r = [];
        for (var n in e)
            Object.prototype.hasOwnProperty.call(e, n) && (r[r.length] = n);
        return r
    }
    ,
    wc(t)
};
function Kv(t) {
    if (t && t.__esModule)
        return t;
    var e = {};
    if (t != null)
        for (var r = wc(t), n = 0; n < r.length; n++)
            r[n] !== "default" && pl(e, t, r[n]);
    return Uk(e, t),
    e
}
function Gv(t) {
    return t && t.__esModule ? t : {
        default: t
    }
}
function Qv(t, e, r, n) {
    if (r === "a" && !n)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? t !== e || !n : !e.has(t))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t)
}
function Jv(t, e, r, n, s) {
    if (n === "m")
        throw new TypeError("Private method is not writable");
    if (n === "a" && !s)
        throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? t !== e || !s : !e.has(t))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return n === "a" ? s.call(t, r) : s ? s.value = r : e.set(t, r),
    r
}
function Yv(t, e) {
    if (e === null || typeof e != "object" && typeof e != "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof t == "function" ? e === t : t.has(e)
}
function Xv(t, e, r) {
    if (e != null) {
        if (typeof e != "object" && typeof e != "function")
            throw new TypeError("Object expected.");
        var n, s;
        if (r) {
            if (!Symbol.asyncDispose)
                throw new TypeError("Symbol.asyncDispose is not defined.");
            n = e[Symbol.asyncDispose]
        }
        if (n === void 0) {
            if (!Symbol.dispose)
                throw new TypeError("Symbol.dispose is not defined.");
            n = e[Symbol.dispose],
            r && (s = n)
        }
        if (typeof n != "function")
            throw new TypeError("Object not disposable.");
        s && (n = function() {
            try {
                s.call(this)
            } catch (i) {
                return Promise.reject(i)
            }
        }
        ),
        t.stack.push({
            value: e,
            dispose: n,
            async: r
        })
    } else
        r && t.stack.push({
            async: !0
        });
    return e
}
var Dk = typeof SuppressedError == "function" ? SuppressedError : function(t, e, r) {
    var n = new Error(r);
    return n.name = "SuppressedError",
    n.error = t,
    n.suppressed = e,
    n
}
;
function Zv(t) {
    function e(i) {
        t.error = t.hasError ? new Dk(i,t.error,"An error was suppressed during disposal.") : i,
        t.hasError = !0
    }
    var r, n = 0;
    function s() {
        for (; r = t.stack.pop(); )
            try {
                if (!r.async && n === 1)
                    return n = 0,
                    t.stack.push(r),
                    Promise.resolve().then(s);
                if (r.dispose) {
                    var i = r.dispose.call(r.value);
                    if (r.async)
                        return n |= 2,
                        Promise.resolve(i).then(s, function(o) {
                            return e(o),
                            s()
                        })
                } else
                    n |= 1
            } catch (o) {
                e(o)
            }
        if (n === 1)
            return t.hasError ? Promise.reject(t.error) : Promise.resolve();
        if (t.hasError)
            throw t.error
    }
    return s()
}
function ey(t, e) {
    return typeof t == "string" && /^\.\.?\//.test(t) ? t.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(r, n, s, i, o) {
        return n ? e ? ".jsx" : ".js" : s && (!i || !o) ? r : s + i + "." + o.toLowerCase() + "js"
    }) : t
}
const Mk = {
    __extends: Rv,
    __assign: Ia,
    __rest: Vs,
    __decorate: jv,
    __param: Av,
    __esDecorate: Nv,
    __runInitializers: Iv,
    __propKey: $v,
    __setFunctionName: Lv,
    __metadata: Uv,
    __awaiter: U,
    __generator: Dv,
    __createBinding: pl,
    __exportStar: Mv,
    __values: $a,
    __read: Wd,
    __spread: Fv,
    __spreadArrays: Bv,
    __spreadArray: zv,
    __await: Ls,
    __asyncGenerator: Vv,
    __asyncDelegator: Wv,
    __asyncValues: Hv,
    __makeTemplateObject: qv,
    __importStar: Kv,
    __importDefault: Gv,
    __classPrivateFieldGet: Qv,
    __classPrivateFieldSet: Jv,
    __classPrivateFieldIn: Yv,
    __addDisposableResource: Xv,
    __disposeResources: Zv,
    __rewriteRelativeImportExtension: ey
}
  , Fk = Object.freeze(Object.defineProperty({
    __proto__: null,
    __addDisposableResource: Xv,
    get __assign() {
        return Ia
    },
    __asyncDelegator: Wv,
    __asyncGenerator: Vv,
    __asyncValues: Hv,
    __await: Ls,
    __awaiter: U,
    __classPrivateFieldGet: Qv,
    __classPrivateFieldIn: Yv,
    __classPrivateFieldSet: Jv,
    __createBinding: pl,
    __decorate: jv,
    __disposeResources: Zv,
    __esDecorate: Nv,
    __exportStar: Mv,
    __extends: Rv,
    __generator: Dv,
    __importDefault: Gv,
    __importStar: Kv,
    __makeTemplateObject: qv,
    __metadata: Uv,
    __param: Av,
    __propKey: $v,
    __read: Wd,
    __rest: Vs,
    __rewriteRelativeImportExtension: ey,
    __runInitializers: Iv,
    __setFunctionName: Lv,
    __spread: Fv,
    __spreadArray: zv,
    __spreadArrays: Bv,
    __values: $a,
    default: Mk
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Bk = t=>t ? (...e)=>t(...e) : (...e)=>fetch(...e);
class Hd extends Error {
    constructor(e, r="FunctionsError", n) {
        super(e),
        this.name = r,
        this.context = n
    }
}
class zk extends Hd {
    constructor(e) {
        super("Failed to send a request to the Edge Function", "FunctionsFetchError", e)
    }
}
class Zf extends Hd {
    constructor(e) {
        super("Relay Error invoking the Edge Function", "FunctionsRelayError", e)
    }
}
class ep extends Hd {
    constructor(e) {
        super("Edge Function returned a non-2xx status code", "FunctionsHttpError", e)
    }
}
var bc;
(function(t) {
    t.Any = "any",
    t.ApNortheast1 = "ap-northeast-1",
    t.ApNortheast2 = "ap-northeast-2",
    t.ApSouth1 = "ap-south-1",
    t.ApSoutheast1 = "ap-southeast-1",
    t.ApSoutheast2 = "ap-southeast-2",
    t.CaCentral1 = "ca-central-1",
    t.EuCentral1 = "eu-central-1",
    t.EuWest1 = "eu-west-1",
    t.EuWest2 = "eu-west-2",
    t.EuWest3 = "eu-west-3",
    t.SaEast1 = "sa-east-1",
    t.UsEast1 = "us-east-1",
    t.UsWest1 = "us-west-1",
    t.UsWest2 = "us-west-2"
}
)(bc || (bc = {}));
class Vk {
    constructor(e, {headers: r={}, customFetch: n, region: s=bc.Any}={}) {
        this.url = e,
        this.headers = r,
        this.region = s,
        this.fetch = Bk(n)
    }
    setAuth(e) {
        this.headers.Authorization = `Bearer ${e}`
    }
    invoke(e) {
        return U(this, arguments, void 0, function*(r, n={}) {
            var s;
            let i, o;
            try {
                const {headers: a, method: l, body: u, signal: c, timeout: h} = n;
                let f = {}
                  , {region: d} = n;
                d || (d = this.region);
                const y = new URL(`${this.url}/${r}`);
                d && d !== "any" && (f["x-region"] = d,
                y.searchParams.set("forceFunctionRegion", d));
                let m;
                u && (a && !Object.prototype.hasOwnProperty.call(a, "Content-Type") || !a) ? typeof Blob < "u" && u instanceof Blob || u instanceof ArrayBuffer ? (f["Content-Type"] = "application/octet-stream",
                m = u) : typeof u == "string" ? (f["Content-Type"] = "text/plain",
                m = u) : typeof FormData < "u" && u instanceof FormData ? m = u : (f["Content-Type"] = "application/json",
                m = JSON.stringify(u)) : m = u;
                let w = c;
                h && (o = new AbortController,
                i = setTimeout(()=>o.abort(), h),
                c ? (w = o.signal,
                c.addEventListener("abort", ()=>o.abort())) : w = o.signal);
                const g = yield this.fetch(y.toString(), {
                    method: l || "POST",
                    headers: Object.assign(Object.assign(Object.assign({}, f), this.headers), a),
                    body: m,
                    signal: w
                }).catch(E=>{
                    throw new zk(E)
                }
                )
                  , p = g.headers.get("x-relay-error");
                if (p && p === "true")
                    throw new Zf(g);
                if (!g.ok)
                    throw new ep(g);
                let v = ((s = g.headers.get("Content-Type")) !== null && s !== void 0 ? s : "text/plain").split(";")[0].trim(), _;
                return v === "application/json" ? _ = yield g.json() : v === "application/octet-stream" || v === "application/pdf" ? _ = yield g.blob() : v === "text/event-stream" ? _ = g : v === "multipart/form-data" ? _ = yield g.formData() : _ = yield g.text(),
                {
                    data: _,
                    error: null,
                    response: g
                }
            } catch (a) {
                return {
                    data: null,
                    error: a,
                    response: a instanceof ep || a instanceof Zf ? a.context : void 0
                }
            } finally {
                i && clearTimeout(i)
            }
        })
    }
}
var ze = {};
const Ws = Wy(Fk);
var Ro = {}, jo = {}, Ao = {}, No = {}, Io = {}, $o = {}, tp;
function ty() {
    if (tp)
        return $o;
    tp = 1,
    Object.defineProperty($o, "__esModule", {
        value: !0
    });
    class t extends Error {
        constructor(r) {
            super(r.message),
            this.name = "PostgrestError",
            this.details = r.details,
            this.hint = r.hint,
            this.code = r.code
        }
    }
    return $o.default = t,
    $o
}
var rp;
function ry() {
    if (rp)
        return Io;
    rp = 1,
    Object.defineProperty(Io, "__esModule", {
        value: !0
    });
    const e = Ws.__importDefault(ty());
    class r {
        constructor(s) {
            var i, o;
            this.shouldThrowOnError = !1,
            this.method = s.method,
            this.url = s.url,
            this.headers = new Headers(s.headers),
            this.schema = s.schema,
            this.body = s.body,
            this.shouldThrowOnError = (i = s.shouldThrowOnError) !== null && i !== void 0 ? i : !1,
            this.signal = s.signal,
            this.isMaybeSingle = (o = s.isMaybeSingle) !== null && o !== void 0 ? o : !1,
            s.fetch ? this.fetch = s.fetch : this.fetch = fetch
        }
        throwOnError() {
            return this.shouldThrowOnError = !0,
            this
        }
        setHeader(s, i) {
            return this.headers = new Headers(this.headers),
            this.headers.set(s, i),
            this
        }
        then(s, i) {
            this.schema === void 0 || (["GET", "HEAD"].includes(this.method) ? this.headers.set("Accept-Profile", this.schema) : this.headers.set("Content-Profile", this.schema)),
            this.method !== "GET" && this.method !== "HEAD" && this.headers.set("Content-Type", "application/json");
            const o = this.fetch;
            let a = o(this.url.toString(), {
                method: this.method,
                headers: this.headers,
                body: JSON.stringify(this.body),
                signal: this.signal
            }).then(async l=>{
                var u, c, h, f;
                let d = null
                  , y = null
                  , m = null
                  , w = l.status
                  , g = l.statusText;
                if (l.ok) {
                    if (this.method !== "HEAD") {
                        const E = await l.text();
                        E === "" || (this.headers.get("Accept") === "text/csv" || this.headers.get("Accept") && (!((u = this.headers.get("Accept")) === null || u === void 0) && u.includes("application/vnd.pgrst.plan+text")) ? y = E : y = JSON.parse(E))
                    }
                    const v = (c = this.headers.get("Prefer")) === null || c === void 0 ? void 0 : c.match(/count=(exact|planned|estimated)/)
                      , _ = (h = l.headers.get("content-range")) === null || h === void 0 ? void 0 : h.split("/");
                    v && _ && _.length > 1 && (m = parseInt(_[1])),
                    this.isMaybeSingle && this.method === "GET" && Array.isArray(y) && (y.length > 1 ? (d = {
                        code: "PGRST116",
                        details: `Results contain ${y.length} rows, application/vnd.pgrst.object+json requires 1 row`,
                        hint: null,
                        message: "JSON object requested, multiple (or no) rows returned"
                    },
                    y = null,
                    m = null,
                    w = 406,
                    g = "Not Acceptable") : y.length === 1 ? y = y[0] : y = null)
                } else {
                    const v = await l.text();
                    try {
                        d = JSON.parse(v),
                        Array.isArray(d) && l.status === 404 && (y = [],
                        d = null,
                        w = 200,
                        g = "OK")
                    } catch {
                        l.status === 404 && v === "" ? (w = 204,
                        g = "No Content") : d = {
                            message: v
                        }
                    }
                    if (d && this.isMaybeSingle && (!((f = d == null ? void 0 : d.details) === null || f === void 0) && f.includes("0 rows")) && (d = null,
                    w = 200,
                    g = "OK"),
                    d && this.shouldThrowOnError)
                        throw new e.default(d)
                }
                return {
                    error: d,
                    data: y,
                    count: m,
                    status: w,
                    statusText: g
                }
            }
            );
            return this.shouldThrowOnError || (a = a.catch(l=>{
                var u, c, h, f, d, y;
                let m = "";
                const w = l == null ? void 0 : l.cause;
                if (w) {
                    const g = (u = w == null ? void 0 : w.message) !== null && u !== void 0 ? u : ""
                      , p = (c = w == null ? void 0 : w.code) !== null && c !== void 0 ? c : "";
                    m = `${(h = l == null ? void 0 : l.name) !== null && h !== void 0 ? h : "FetchError"}: ${l == null ? void 0 : l.message}`,
                    m += `

Caused by: ${(f = w == null ? void 0 : w.name) !== null && f !== void 0 ? f : "Error"}: ${g}`,
                    p && (m += ` (${p})`),
                    w != null && w.stack && (m += `
${w.stack}`)
                } else
                    m = (d = l == null ? void 0 : l.stack) !== null && d !== void 0 ? d : "";
                return {
                    error: {
                        message: `${(y = l == null ? void 0 : l.name) !== null && y !== void 0 ? y : "FetchError"}: ${l == null ? void 0 : l.message}`,
                        details: m,
                        hint: "",
                        code: ""
                    },
                    data: null,
                    count: null,
                    status: 0,
                    statusText: ""
                }
            }
            )),
            a.then(s, i)
        }
        returns() {
            return this
        }
        overrideTypes() {
            return this
        }
    }
    return Io.default = r,
    Io
}
var np;
function ny() {
    if (np)
        return No;
    np = 1,
    Object.defineProperty(No, "__esModule", {
        value: !0
    });
    const e = Ws.__importDefault(ry());
    class r extends e.default {
        select(s) {
            let i = !1;
            const o = (s ?? "*").split("").map(a=>/\s/.test(a) && !i ? "" : (a === '"' && (i = !i),
            a)).join("");
            return this.url.searchParams.set("select", o),
            this.headers.append("Prefer", "return=representation"),
            this
        }
        order(s, {ascending: i=!0, nullsFirst: o, foreignTable: a, referencedTable: l=a}={}) {
            const u = l ? `${l}.order` : "order"
              , c = this.url.searchParams.get(u);
            return this.url.searchParams.set(u, `${c ? `${c},` : ""}${s}.${i ? "asc" : "desc"}${o === void 0 ? "" : o ? ".nullsfirst" : ".nullslast"}`),
            this
        }
        limit(s, {foreignTable: i, referencedTable: o=i}={}) {
            const a = typeof o > "u" ? "limit" : `${o}.limit`;
            return this.url.searchParams.set(a, `${s}`),
            this
        }
        range(s, i, {foreignTable: o, referencedTable: a=o}={}) {
            const l = typeof a > "u" ? "offset" : `${a}.offset`
              , u = typeof a > "u" ? "limit" : `${a}.limit`;
            return this.url.searchParams.set(l, `${s}`),
            this.url.searchParams.set(u, `${i - s + 1}`),
            this
        }
        abortSignal(s) {
            return this.signal = s,
            this
        }
        single() {
            return this.headers.set("Accept", "application/vnd.pgrst.object+json"),
            this
        }
        maybeSingle() {
            return this.method === "GET" ? this.headers.set("Accept", "application/json") : this.headers.set("Accept", "application/vnd.pgrst.object+json"),
            this.isMaybeSingle = !0,
            this
        }
        csv() {
            return this.headers.set("Accept", "text/csv"),
            this
        }
        geojson() {
            return this.headers.set("Accept", "application/geo+json"),
            this
        }
        explain({analyze: s=!1, verbose: i=!1, settings: o=!1, buffers: a=!1, wal: l=!1, format: u="text"}={}) {
            var c;
            const h = [s ? "analyze" : null, i ? "verbose" : null, o ? "settings" : null, a ? "buffers" : null, l ? "wal" : null].filter(Boolean).join("|")
              , f = (c = this.headers.get("Accept")) !== null && c !== void 0 ? c : "application/json";
            return this.headers.set("Accept", `application/vnd.pgrst.plan+${u}; for="${f}"; options=${h};`),
            u === "json" ? this : this
        }
        rollback() {
            return this.headers.append("Prefer", "tx=rollback"),
            this
        }
        returns() {
            return this
        }
        maxAffected(s) {
            return this.headers.append("Prefer", "handling=strict"),
            this.headers.append("Prefer", `max-affected=${s}`),
            this
        }
    }
    return No.default = r,
    No
}
var sp;
function qd() {
    if (sp)
        return Ao;
    sp = 1,
    Object.defineProperty(Ao, "__esModule", {
        value: !0
    });
    const e = Ws.__importDefault(ny())
      , r = new RegExp("[,()]");
    class n extends e.default {
        eq(i, o) {
            return this.url.searchParams.append(i, `eq.${o}`),
            this
        }
        neq(i, o) {
            return this.url.searchParams.append(i, `neq.${o}`),
            this
        }
        gt(i, o) {
            return this.url.searchParams.append(i, `gt.${o}`),
            this
        }
        gte(i, o) {
            return this.url.searchParams.append(i, `gte.${o}`),
            this
        }
        lt(i, o) {
            return this.url.searchParams.append(i, `lt.${o}`),
            this
        }
        lte(i, o) {
            return this.url.searchParams.append(i, `lte.${o}`),
            this
        }
        like(i, o) {
            return this.url.searchParams.append(i, `like.${o}`),
            this
        }
        likeAllOf(i, o) {
            return this.url.searchParams.append(i, `like(all).{${o.join(",")}}`),
            this
        }
        likeAnyOf(i, o) {
            return this.url.searchParams.append(i, `like(any).{${o.join(",")}}`),
            this
        }
        ilike(i, o) {
            return this.url.searchParams.append(i, `ilike.${o}`),
            this
        }
        ilikeAllOf(i, o) {
            return this.url.searchParams.append(i, `ilike(all).{${o.join(",")}}`),
            this
        }
        ilikeAnyOf(i, o) {
            return this.url.searchParams.append(i, `ilike(any).{${o.join(",")}}`),
            this
        }
        regexMatch(i, o) {
            return this.url.searchParams.append(i, `match.${o}`),
            this
        }
        regexIMatch(i, o) {
            return this.url.searchParams.append(i, `imatch.${o}`),
            this
        }
        is(i, o) {
            return this.url.searchParams.append(i, `is.${o}`),
            this
        }
        isDistinct(i, o) {
            return this.url.searchParams.append(i, `isdistinct.${o}`),
            this
        }
        in(i, o) {
            const a = Array.from(new Set(o)).map(l=>typeof l == "string" && r.test(l) ? `"${l}"` : `${l}`).join(",");
            return this.url.searchParams.append(i, `in.(${a})`),
            this
        }
        contains(i, o) {
            return typeof o == "string" ? this.url.searchParams.append(i, `cs.${o}`) : Array.isArray(o) ? this.url.searchParams.append(i, `cs.{${o.join(",")}}`) : this.url.searchParams.append(i, `cs.${JSON.stringify(o)}`),
            this
        }
        containedBy(i, o) {
            return typeof o == "string" ? this.url.searchParams.append(i, `cd.${o}`) : Array.isArray(o) ? this.url.searchParams.append(i, `cd.{${o.join(",")}}`) : this.url.searchParams.append(i, `cd.${JSON.stringify(o)}`),
            this
        }
        rangeGt(i, o) {
            return this.url.searchParams.append(i, `sr.${o}`),
            this
        }
        rangeGte(i, o) {
            return this.url.searchParams.append(i, `nxl.${o}`),
            this
        }
        rangeLt(i, o) {
            return this.url.searchParams.append(i, `sl.${o}`),
            this
        }
        rangeLte(i, o) {
            return this.url.searchParams.append(i, `nxr.${o}`),
            this
        }
        rangeAdjacent(i, o) {
            return this.url.searchParams.append(i, `adj.${o}`),
            this
        }
        overlaps(i, o) {
            return typeof o == "string" ? this.url.searchParams.append(i, `ov.${o}`) : this.url.searchParams.append(i, `ov.{${o.join(",")}}`),
            this
        }
        textSearch(i, o, {config: a, type: l}={}) {
            let u = "";
            l === "plain" ? u = "pl" : l === "phrase" ? u = "ph" : l === "websearch" && (u = "w");
            const c = a === void 0 ? "" : `(${a})`;
            return this.url.searchParams.append(i, `${u}fts ${c}.${o}`),
            this
        }
        match(i) {
            return Object.entries(i).forEach(([o,a])=>{
                this.url.searchParams.append(o, `eq.${a}`)
            }
            ),
            this
        }
        not(i, o, a) {
            return this.url.searchParams.append(i, `not.${o}.${a}`),
            this
        }
        or(i, {foreignTable: o, referencedTable: a=o}={}) {
            const l = a ? `${a}.or` : "or";
            return this.url.searchParams.append(l, `(${i})`),
            this
        }
        filter(i, o, a) {
            return this.url.searchParams.append(i, `${o}.${a}`),
            this
        }
    }
    return Ao.default = n,
    Ao
}
var ip;
function sy() {
    if (ip)
        return jo;
    ip = 1,
    Object.defineProperty(jo, "__esModule", {
        value: !0
    });
    const e = Ws.__importDefault(qd());
    class r {
        constructor(s, {headers: i={}, schema: o, fetch: a}) {
            this.url = s,
            this.headers = new Headers(i),
            this.schema = o,
            this.fetch = a
        }
        select(s, i) {
            const {head: o=!1, count: a} = i ?? {}
              , l = o ? "HEAD" : "GET";
            let u = !1;
            const c = (s ?? "*").split("").map(h=>/\s/.test(h) && !u ? "" : (h === '"' && (u = !u),
            h)).join("");
            return this.url.searchParams.set("select", c),
            a && this.headers.append("Prefer", `count=${a}`),
            new e.default({
                method: l,
                url: this.url,
                headers: this.headers,
                schema: this.schema,
                fetch: this.fetch
            })
        }
        insert(s, {count: i, defaultToNull: o=!0}={}) {
            var a;
            const l = "POST";
            if (i && this.headers.append("Prefer", `count=${i}`),
            o || this.headers.append("Prefer", "missing=default"),
            Array.isArray(s)) {
                const u = s.reduce((c,h)=>c.concat(Object.keys(h)), []);
                if (u.length > 0) {
                    const c = [...new Set(u)].map(h=>`"${h}"`);
                    this.url.searchParams.set("columns", c.join(","))
                }
            }
            return new e.default({
                method: l,
                url: this.url,
                headers: this.headers,
                schema: this.schema,
                body: s,
                fetch: (a = this.fetch) !== null && a !== void 0 ? a : fetch
            })
        }
        upsert(s, {onConflict: i, ignoreDuplicates: o=!1, count: a, defaultToNull: l=!0}={}) {
            var u;
            const c = "POST";
            if (this.headers.append("Prefer", `resolution=${o ? "ignore" : "merge"}-duplicates`),
            i !== void 0 && this.url.searchParams.set("on_conflict", i),
            a && this.headers.append("Prefer", `count=${a}`),
            l || this.headers.append("Prefer", "missing=default"),
            Array.isArray(s)) {
                const h = s.reduce((f,d)=>f.concat(Object.keys(d)), []);
                if (h.length > 0) {
                    const f = [...new Set(h)].map(d=>`"${d}"`);
                    this.url.searchParams.set("columns", f.join(","))
                }
            }
            return new e.default({
                method: c,
                url: this.url,
                headers: this.headers,
                schema: this.schema,
                body: s,
                fetch: (u = this.fetch) !== null && u !== void 0 ? u : fetch
            })
        }
        update(s, {count: i}={}) {
            var o;
            const a = "PATCH";
            return i && this.headers.append("Prefer", `count=${i}`),
            new e.default({
                method: a,
                url: this.url,
                headers: this.headers,
                schema: this.schema,
                body: s,
                fetch: (o = this.fetch) !== null && o !== void 0 ? o : fetch
            })
        }
        delete({count: s}={}) {
            var i;
            const o = "DELETE";
            return s && this.headers.append("Prefer", `count=${s}`),
            new e.default({
                method: o,
                url: this.url,
                headers: this.headers,
                schema: this.schema,
                fetch: (i = this.fetch) !== null && i !== void 0 ? i : fetch
            })
        }
    }
    return jo.default = r,
    jo
}
var op;
function Wk() {
    if (op)
        return Ro;
    op = 1,
    Object.defineProperty(Ro, "__esModule", {
        value: !0
    });
    const t = Ws
      , e = t.__importDefault(sy())
      , r = t.__importDefault(qd());
    class n {
        constructor(i, {headers: o={}, schema: a, fetch: l}={}) {
            this.url = i,
            this.headers = new Headers(o),
            this.schemaName = a,
            this.fetch = l
        }
        from(i) {
            if (!i || typeof i != "string" || i.trim() === "")
                throw new Error("Invalid relation name: relation must be a non-empty string.");
            const o = new URL(`${this.url}/${i}`);
            return new e.default(o,{
                headers: new Headers(this.headers),
                schema: this.schemaName,
                fetch: this.fetch
            })
        }
        schema(i) {
            return new n(this.url,{
                headers: this.headers,
                schema: i,
                fetch: this.fetch
            })
        }
        rpc(i, o={}, {head: a=!1, get: l=!1, count: u}={}) {
            var c;
            let h;
            const f = new URL(`${this.url}/rpc/${i}`);
            let d;
            a || l ? (h = a ? "HEAD" : "GET",
            Object.entries(o).filter(([m,w])=>w !== void 0).map(([m,w])=>[m, Array.isArray(w) ? `{${w.join(",")}}` : `${w}`]).forEach(([m,w])=>{
                f.searchParams.append(m, w)
            }
            )) : (h = "POST",
            d = o);
            const y = new Headers(this.headers);
            return u && y.set("Prefer", `count=${u}`),
            new r.default({
                method: h,
                url: f,
                headers: y,
                schema: this.schemaName,
                body: d,
                fetch: (c = this.fetch) !== null && c !== void 0 ? c : fetch
            })
        }
    }
    return Ro.default = n,
    Ro
}
Object.defineProperty(ze, "__esModule", {
    value: !0
});
var iy = ze.PostgrestError = my = ze.PostgrestBuilder = fy = ze.PostgrestTransformBuilder = dy = ze.PostgrestFilterBuilder = uy = ze.PostgrestQueryBuilder = ay = ze.PostgrestClient = void 0;
const Hs = Ws
  , oy = Hs.__importDefault(Wk());
var ay = ze.PostgrestClient = oy.default;
const ly = Hs.__importDefault(sy());
var uy = ze.PostgrestQueryBuilder = ly.default;
const cy = Hs.__importDefault(qd());
var dy = ze.PostgrestFilterBuilder = cy.default;
const hy = Hs.__importDefault(ny());
var fy = ze.PostgrestTransformBuilder = hy.default;
const py = Hs.__importDefault(ry());
var my = ze.PostgrestBuilder = py.default;
const gy = Hs.__importDefault(ty());
iy = ze.PostgrestError = gy.default;
var vy = ze.default = {
    PostgrestClient: oy.default,
    PostgrestQueryBuilder: ly.default,
    PostgrestFilterBuilder: cy.default,
    PostgrestTransformBuilder: hy.default,
    PostgrestBuilder: py.default,
    PostgrestError: gy.default
};
const Hk = Lp({
    __proto__: null,
    get PostgrestBuilder() {
        return my
    },
    get PostgrestClient() {
        return ay
    },
    get PostgrestError() {
        return iy
    },
    get PostgrestFilterBuilder() {
        return dy
    },
    get PostgrestQueryBuilder() {
        return uy
    },
    get PostgrestTransformBuilder() {
        return fy
    },
    default: vy
}, [ze])
  , {PostgrestClient: qk, PostgrestQueryBuilder: kP, PostgrestFilterBuilder: TP, PostgrestTransformBuilder: CP, PostgrestBuilder: PP, PostgrestError: OP} = vy || Hk;
class Kk {
    constructor() {}
    static detectEnvironment() {
        var e;
        if (typeof WebSocket < "u")
            return {
                type: "native",
                constructor: WebSocket
            };
        if (typeof globalThis < "u" && typeof globalThis.WebSocket < "u")
            return {
                type: "native",
                constructor: globalThis.WebSocket
            };
        if (typeof global < "u" && typeof global.WebSocket < "u")
            return {
                type: "native",
                constructor: global.WebSocket
            };
        if (typeof globalThis < "u" && typeof globalThis.WebSocketPair < "u" && typeof globalThis.WebSocket > "u")
            return {
                type: "cloudflare",
                error: "Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",
                workaround: "Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime."
            };
        if (typeof globalThis < "u" && globalThis.EdgeRuntime || typeof navigator < "u" && (!((e = navigator.userAgent) === null || e === void 0) && e.includes("Vercel-Edge")))
            return {
                type: "unsupported",
                error: "Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",
                workaround: "Use serverless functions or a different deployment target for WebSocket functionality."
            };
        if (typeof process < "u") {
            const r = process.versions;
            if (r && r.node) {
                const n = r.node
                  , s = parseInt(n.replace(/^v/, "").split(".")[0]);
                return s >= 22 ? typeof globalThis.WebSocket < "u" ? {
                    type: "native",
                    constructor: globalThis.WebSocket
                } : {
                    type: "unsupported",
                    error: `Node.js ${s} detected but native WebSocket not found.`,
                    workaround: "Provide a WebSocket implementation via the transport option."
                } : {
                    type: "unsupported",
                    error: `Node.js ${s} detected without native WebSocket support.`,
                    workaround: `For Node.js < 22, install "ws" package and provide it via the transport option:
import ws from "ws"
new RealtimeClient(url, { transport: ws })`
                }
            }
        }
        return {
            type: "unsupported",
            error: "Unknown JavaScript runtime without WebSocket support.",
            workaround: "Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."
        }
    }
    static getWebSocketConstructor() {
        const e = this.detectEnvironment();
        if (e.constructor)
            return e.constructor;
        let r = e.error || "WebSocket not supported in this environment.";
        throw e.workaround && (r += `

Suggested solution: ${e.workaround}`),
        new Error(r)
    }
    static createWebSocket(e, r) {
        const n = this.getWebSocketConstructor();
        return new n(e,r)
    }
    static isWebSocketSupported() {
        try {
            const e = this.detectEnvironment();
            return e.type === "native" || e.type === "ws"
        } catch {
            return !1
        }
    }
}
const Gk = "2.86.0"
  , Qk = `realtime-js/${Gk}`
  , yy = "1.0.0"
  , Jk = "2.0.0"
  , ap = yy
  , _c = 1e4
  , Yk = 1e3
  , Xk = 100;
var hn;
(function(t) {
    t[t.connecting = 0] = "connecting",
    t[t.open = 1] = "open",
    t[t.closing = 2] = "closing",
    t[t.closed = 3] = "closed"
}
)(hn || (hn = {}));
var xe;
(function(t) {
    t.closed = "closed",
    t.errored = "errored",
    t.joined = "joined",
    t.joining = "joining",
    t.leaving = "leaving"
}
)(xe || (xe = {}));
var jt;
(function(t) {
    t.close = "phx_close",
    t.error = "phx_error",
    t.join = "phx_join",
    t.reply = "phx_reply",
    t.leave = "phx_leave",
    t.access_token = "access_token"
}
)(jt || (jt = {}));
var xc;
(function(t) {
    t.websocket = "websocket"
}
)(xc || (xc = {}));
var fn;
(function(t) {
    t.Connecting = "connecting",
    t.Open = "open",
    t.Closing = "closing",
    t.Closed = "closed"
}
)(fn || (fn = {}));
class Zk {
    constructor(e) {
        this.HEADER_LENGTH = 1,
        this.USER_BROADCAST_PUSH_META_LENGTH = 6,
        this.KINDS = {
            userBroadcastPush: 3,
            userBroadcast: 4
        },
        this.BINARY_ENCODING = 0,
        this.JSON_ENCODING = 1,
        this.BROADCAST_EVENT = "broadcast",
        this.allowedMetadataKeys = [],
        this.allowedMetadataKeys = e ?? []
    }
    encode(e, r) {
        if (e.event === this.BROADCAST_EVENT && !(e.payload instanceof ArrayBuffer) && typeof e.payload.event == "string")
            return r(this._binaryEncodeUserBroadcastPush(e));
        let n = [e.join_ref, e.ref, e.topic, e.event, e.payload];
        return r(JSON.stringify(n))
    }
    _binaryEncodeUserBroadcastPush(e) {
        var r;
        return this._isArrayBuffer((r = e.payload) === null || r === void 0 ? void 0 : r.payload) ? this._encodeBinaryUserBroadcastPush(e) : this._encodeJsonUserBroadcastPush(e)
    }
    _encodeBinaryUserBroadcastPush(e) {
        var r, n;
        const s = (n = (r = e.payload) === null || r === void 0 ? void 0 : r.payload) !== null && n !== void 0 ? n : new ArrayBuffer(0);
        return this._encodeUserBroadcastPush(e, this.BINARY_ENCODING, s)
    }
    _encodeJsonUserBroadcastPush(e) {
        var r, n;
        const s = (n = (r = e.payload) === null || r === void 0 ? void 0 : r.payload) !== null && n !== void 0 ? n : {}
          , o = new TextEncoder().encode(JSON.stringify(s)).buffer;
        return this._encodeUserBroadcastPush(e, this.JSON_ENCODING, o)
    }
    _encodeUserBroadcastPush(e, r, n) {
        var s, i;
        const o = e.topic
          , a = (s = e.ref) !== null && s !== void 0 ? s : ""
          , l = (i = e.join_ref) !== null && i !== void 0 ? i : ""
          , u = e.payload.event
          , c = this.allowedMetadataKeys ? this._pick(e.payload, this.allowedMetadataKeys) : {}
          , h = Object.keys(c).length === 0 ? "" : JSON.stringify(c);
        if (l.length > 255)
            throw new Error(`joinRef length ${l.length} exceeds maximum of 255`);
        if (a.length > 255)
            throw new Error(`ref length ${a.length} exceeds maximum of 255`);
        if (o.length > 255)
            throw new Error(`topic length ${o.length} exceeds maximum of 255`);
        if (u.length > 255)
            throw new Error(`userEvent length ${u.length} exceeds maximum of 255`);
        if (h.length > 255)
            throw new Error(`metadata length ${h.length} exceeds maximum of 255`);
        const f = this.USER_BROADCAST_PUSH_META_LENGTH + l.length + a.length + o.length + u.length + h.length
          , d = new ArrayBuffer(this.HEADER_LENGTH + f);
        let y = new DataView(d)
          , m = 0;
        y.setUint8(m++, this.KINDS.userBroadcastPush),
        y.setUint8(m++, l.length),
        y.setUint8(m++, a.length),
        y.setUint8(m++, o.length),
        y.setUint8(m++, u.length),
        y.setUint8(m++, h.length),
        y.setUint8(m++, r),
        Array.from(l, g=>y.setUint8(m++, g.charCodeAt(0))),
        Array.from(a, g=>y.setUint8(m++, g.charCodeAt(0))),
        Array.from(o, g=>y.setUint8(m++, g.charCodeAt(0))),
        Array.from(u, g=>y.setUint8(m++, g.charCodeAt(0))),
        Array.from(h, g=>y.setUint8(m++, g.charCodeAt(0)));
        var w = new Uint8Array(d.byteLength + n.byteLength);
        return w.set(new Uint8Array(d), 0),
        w.set(new Uint8Array(n), d.byteLength),
        w.buffer
    }
    decode(e, r) {
        if (this._isArrayBuffer(e)) {
            let n = this._binaryDecode(e);
            return r(n)
        }
        if (typeof e == "string") {
            const n = JSON.parse(e)
              , [s,i,o,a,l] = n;
            return r({
                join_ref: s,
                ref: i,
                topic: o,
                event: a,
                payload: l
            })
        }
        return r({})
    }
    _binaryDecode(e) {
        const r = new DataView(e)
          , n = r.getUint8(0)
          , s = new TextDecoder;
        switch (n) {
        case this.KINDS.userBroadcast:
            return this._decodeUserBroadcast(e, r, s)
        }
    }
    _decodeUserBroadcast(e, r, n) {
        const s = r.getUint8(1)
          , i = r.getUint8(2)
          , o = r.getUint8(3)
          , a = r.getUint8(4);
        let l = this.HEADER_LENGTH + 4;
        const u = n.decode(e.slice(l, l + s));
        l = l + s;
        const c = n.decode(e.slice(l, l + i));
        l = l + i;
        const h = n.decode(e.slice(l, l + o));
        l = l + o;
        const f = e.slice(l, e.byteLength)
          , d = a === this.JSON_ENCODING ? JSON.parse(n.decode(f)) : f
          , y = {
            type: this.BROADCAST_EVENT,
            event: c,
            payload: d
        };
        return o > 0 && (y.meta = JSON.parse(h)),
        {
            join_ref: null,
            ref: null,
            topic: u,
            event: this.BROADCAST_EVENT,
            payload: y
        }
    }
    _isArrayBuffer(e) {
        var r;
        return e instanceof ArrayBuffer || ((r = e == null ? void 0 : e.constructor) === null || r === void 0 ? void 0 : r.name) === "ArrayBuffer"
    }
    _pick(e, r) {
        return !e || typeof e != "object" ? {} : Object.fromEntries(Object.entries(e).filter(([n])=>r.includes(n)))
    }
}
class wy {
    constructor(e, r) {
        this.callback = e,
        this.timerCalc = r,
        this.timer = void 0,
        this.tries = 0,
        this.callback = e,
        this.timerCalc = r
    }
    reset() {
        this.tries = 0,
        clearTimeout(this.timer),
        this.timer = void 0
    }
    scheduleTimeout() {
        clearTimeout(this.timer),
        this.timer = setTimeout(()=>{
            this.tries = this.tries + 1,
            this.callback()
        }
        , this.timerCalc(this.tries + 1))
    }
}
var ie;
(function(t) {
    t.abstime = "abstime",
    t.bool = "bool",
    t.date = "date",
    t.daterange = "daterange",
    t.float4 = "float4",
    t.float8 = "float8",
    t.int2 = "int2",
    t.int4 = "int4",
    t.int4range = "int4range",
    t.int8 = "int8",
    t.int8range = "int8range",
    t.json = "json",
    t.jsonb = "jsonb",
    t.money = "money",
    t.numeric = "numeric",
    t.oid = "oid",
    t.reltime = "reltime",
    t.text = "text",
    t.time = "time",
    t.timestamp = "timestamp",
    t.timestamptz = "timestamptz",
    t.timetz = "timetz",
    t.tsrange = "tsrange",
    t.tstzrange = "tstzrange"
}
)(ie || (ie = {}));
const lp = (t,e,r={})=>{
    var n;
    const s = (n = r.skipTypes) !== null && n !== void 0 ? n : [];
    return e ? Object.keys(e).reduce((i,o)=>(i[o] = eT(o, t, e, s),
    i), {}) : {}
}
  , eT = (t,e,r,n)=>{
    const s = e.find(a=>a.name === t)
      , i = s == null ? void 0 : s.type
      , o = r[t];
    return i && !n.includes(i) ? by(i, o) : Ec(o)
}
  , by = (t,e)=>{
    if (t.charAt(0) === "_") {
        const r = t.slice(1, t.length);
        return sT(e, r)
    }
    switch (t) {
    case ie.bool:
        return tT(e);
    case ie.float4:
    case ie.float8:
    case ie.int2:
    case ie.int4:
    case ie.int8:
    case ie.numeric:
    case ie.oid:
        return rT(e);
    case ie.json:
    case ie.jsonb:
        return nT(e);
    case ie.timestamp:
        return iT(e);
    case ie.abstime:
    case ie.date:
    case ie.daterange:
    case ie.int4range:
    case ie.int8range:
    case ie.money:
    case ie.reltime:
    case ie.text:
    case ie.time:
    case ie.timestamptz:
    case ie.timetz:
    case ie.tsrange:
    case ie.tstzrange:
        return Ec(e);
    default:
        return Ec(e)
    }
}
  , Ec = t=>t
  , tT = t=>{
    switch (t) {
    case "t":
        return !0;
    case "f":
        return !1;
    default:
        return t
    }
}
  , rT = t=>{
    if (typeof t == "string") {
        const e = parseFloat(t);
        if (!Number.isNaN(e))
            return e
    }
    return t
}
  , nT = t=>{
    if (typeof t == "string")
        try {
            return JSON.parse(t)
        } catch (e) {
            return console.log(`JSON parse error: ${e}`),
            t
        }
    return t
}
  , sT = (t,e)=>{
    if (typeof t != "string")
        return t;
    const r = t.length - 1
      , n = t[r];
    if (t[0] === "{" && n === "}") {
        let i;
        const o = t.slice(1, r);
        try {
            i = JSON.parse("[" + o + "]")
        } catch {
            i = o ? o.split(",") : []
        }
        return i.map(a=>by(e, a))
    }
    return t
}
  , iT = t=>typeof t == "string" ? t.replace(" ", "T") : t
  , _y = t=>{
    const e = new URL(t);
    return e.protocol = e.protocol.replace(/^ws/i, "http"),
    e.pathname = e.pathname.replace(/\/+$/, "").replace(/\/socket\/websocket$/i, "").replace(/\/socket$/i, "").replace(/\/websocket$/i, ""),
    e.pathname === "" || e.pathname === "/" ? e.pathname = "/api/broadcast" : e.pathname = e.pathname + "/api/broadcast",
    e.href
}
;
class tu {
    constructor(e, r, n={}, s=_c) {
        this.channel = e,
        this.event = r,
        this.payload = n,
        this.timeout = s,
        this.sent = !1,
        this.timeoutTimer = void 0,
        this.ref = "",
        this.receivedResp = null,
        this.recHooks = [],
        this.refEvent = null
    }
    resend(e) {
        this.timeout = e,
        this._cancelRefEvent(),
        this.ref = "",
        this.refEvent = null,
        this.receivedResp = null,
        this.sent = !1,
        this.send()
    }
    send() {
        this._hasReceived("timeout") || (this.startTimeout(),
        this.sent = !0,
        this.channel.socket.push({
            topic: this.channel.topic,
            event: this.event,
            payload: this.payload,
            ref: this.ref,
            join_ref: this.channel._joinRef()
        }))
    }
    updatePayload(e) {
        this.payload = Object.assign(Object.assign({}, this.payload), e)
    }
    receive(e, r) {
        var n;
        return this._hasReceived(e) && r((n = this.receivedResp) === null || n === void 0 ? void 0 : n.response),
        this.recHooks.push({
            status: e,
            callback: r
        }),
        this
    }
    startTimeout() {
        if (this.timeoutTimer)
            return;
        this.ref = this.channel.socket._makeRef(),
        this.refEvent = this.channel._replyEventName(this.ref);
        const e = r=>{
            this._cancelRefEvent(),
            this._cancelTimeout(),
            this.receivedResp = r,
            this._matchReceive(r)
        }
        ;
        this.channel._on(this.refEvent, {}, e),
        this.timeoutTimer = setTimeout(()=>{
            this.trigger("timeout", {})
        }
        , this.timeout)
    }
    trigger(e, r) {
        this.refEvent && this.channel._trigger(this.refEvent, {
            status: e,
            response: r
        })
    }
    destroy() {
        this._cancelRefEvent(),
        this._cancelTimeout()
    }
    _cancelRefEvent() {
        this.refEvent && this.channel._off(this.refEvent, {})
    }
    _cancelTimeout() {
        clearTimeout(this.timeoutTimer),
        this.timeoutTimer = void 0
    }
    _matchReceive({status: e, response: r}) {
        this.recHooks.filter(n=>n.status === e).forEach(n=>n.callback(r))
    }
    _hasReceived(e) {
        return this.receivedResp && this.receivedResp.status === e
    }
}
var up;
(function(t) {
    t.SYNC = "sync",
    t.JOIN = "join",
    t.LEAVE = "leave"
}
)(up || (up = {}));
class wi {
    constructor(e, r) {
        this.channel = e,
        this.state = {},
        this.pendingDiffs = [],
        this.joinRef = null,
        this.enabled = !1,
        this.caller = {
            onJoin: ()=>{}
            ,
            onLeave: ()=>{}
            ,
            onSync: ()=>{}
        };
        const n = (r == null ? void 0 : r.events) || {
            state: "presence_state",
            diff: "presence_diff"
        };
        this.channel._on(n.state, {}, s=>{
            const {onJoin: i, onLeave: o, onSync: a} = this.caller;
            this.joinRef = this.channel._joinRef(),
            this.state = wi.syncState(this.state, s, i, o),
            this.pendingDiffs.forEach(l=>{
                this.state = wi.syncDiff(this.state, l, i, o)
            }
            ),
            this.pendingDiffs = [],
            a()
        }
        ),
        this.channel._on(n.diff, {}, s=>{
            const {onJoin: i, onLeave: o, onSync: a} = this.caller;
            this.inPendingSyncState() ? this.pendingDiffs.push(s) : (this.state = wi.syncDiff(this.state, s, i, o),
            a())
        }
        ),
        this.onJoin((s,i,o)=>{
            this.channel._trigger("presence", {
                event: "join",
                key: s,
                currentPresences: i,
                newPresences: o
            })
        }
        ),
        this.onLeave((s,i,o)=>{
            this.channel._trigger("presence", {
                event: "leave",
                key: s,
                currentPresences: i,
                leftPresences: o
            })
        }
        ),
        this.onSync(()=>{
            this.channel._trigger("presence", {
                event: "sync"
            })
        }
        )
    }
    static syncState(e, r, n, s) {
        const i = this.cloneDeep(e)
          , o = this.transformState(r)
          , a = {}
          , l = {};
        return this.map(i, (u,c)=>{
            o[u] || (l[u] = c)
        }
        ),
        this.map(o, (u,c)=>{
            const h = i[u];
            if (h) {
                const f = c.map(w=>w.presence_ref)
                  , d = h.map(w=>w.presence_ref)
                  , y = c.filter(w=>d.indexOf(w.presence_ref) < 0)
                  , m = h.filter(w=>f.indexOf(w.presence_ref) < 0);
                y.length > 0 && (a[u] = y),
                m.length > 0 && (l[u] = m)
            } else
                a[u] = c
        }
        ),
        this.syncDiff(i, {
            joins: a,
            leaves: l
        }, n, s)
    }
    static syncDiff(e, r, n, s) {
        const {joins: i, leaves: o} = {
            joins: this.transformState(r.joins),
            leaves: this.transformState(r.leaves)
        };
        return n || (n = ()=>{}
        ),
        s || (s = ()=>{}
        ),
        this.map(i, (a,l)=>{
            var u;
            const c = (u = e[a]) !== null && u !== void 0 ? u : [];
            if (e[a] = this.cloneDeep(l),
            c.length > 0) {
                const h = e[a].map(d=>d.presence_ref)
                  , f = c.filter(d=>h.indexOf(d.presence_ref) < 0);
                e[a].unshift(...f)
            }
            n(a, c, l)
        }
        ),
        this.map(o, (a,l)=>{
            let u = e[a];
            if (!u)
                return;
            const c = l.map(h=>h.presence_ref);
            u = u.filter(h=>c.indexOf(h.presence_ref) < 0),
            e[a] = u,
            s(a, u, l),
            u.length === 0 && delete e[a]
        }
        ),
        e
    }
    static map(e, r) {
        return Object.getOwnPropertyNames(e).map(n=>r(n, e[n]))
    }
    static transformState(e) {
        return e = this.cloneDeep(e),
        Object.getOwnPropertyNames(e).reduce((r,n)=>{
            const s = e[n];
            return "metas"in s ? r[n] = s.metas.map(i=>(i.presence_ref = i.phx_ref,
            delete i.phx_ref,
            delete i.phx_ref_prev,
            i)) : r[n] = s,
            r
        }
        , {})
    }
    static cloneDeep(e) {
        return JSON.parse(JSON.stringify(e))
    }
    onJoin(e) {
        this.caller.onJoin = e
    }
    onLeave(e) {
        this.caller.onLeave = e
    }
    onSync(e) {
        this.caller.onSync = e
    }
    inPendingSyncState() {
        return !this.joinRef || this.joinRef !== this.channel._joinRef()
    }
}
var cp;
(function(t) {
    t.ALL = "*",
    t.INSERT = "INSERT",
    t.UPDATE = "UPDATE",
    t.DELETE = "DELETE"
}
)(cp || (cp = {}));
var bi;
(function(t) {
    t.BROADCAST = "broadcast",
    t.PRESENCE = "presence",
    t.POSTGRES_CHANGES = "postgres_changes",
    t.SYSTEM = "system"
}
)(bi || (bi = {}));
var tr;
(function(t) {
    t.SUBSCRIBED = "SUBSCRIBED",
    t.TIMED_OUT = "TIMED_OUT",
    t.CLOSED = "CLOSED",
    t.CHANNEL_ERROR = "CHANNEL_ERROR"
}
)(tr || (tr = {}));
class Kd {
    constructor(e, r={
        config: {}
    }, n) {
        var s, i;
        if (this.topic = e,
        this.params = r,
        this.socket = n,
        this.bindings = {},
        this.state = xe.closed,
        this.joinedOnce = !1,
        this.pushBuffer = [],
        this.subTopic = e.replace(/^realtime:/i, ""),
        this.params.config = Object.assign({
            broadcast: {
                ack: !1,
                self: !1
            },
            presence: {
                key: "",
                enabled: !1
            },
            private: !1
        }, r.config),
        this.timeout = this.socket.timeout,
        this.joinPush = new tu(this,jt.join,this.params,this.timeout),
        this.rejoinTimer = new wy(()=>this._rejoinUntilConnected(),this.socket.reconnectAfterMs),
        this.joinPush.receive("ok", ()=>{
            this.state = xe.joined,
            this.rejoinTimer.reset(),
            this.pushBuffer.forEach(o=>o.send()),
            this.pushBuffer = []
        }
        ),
        this._onClose(()=>{
            this.rejoinTimer.reset(),
            this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`),
            this.state = xe.closed,
            this.socket._remove(this)
        }
        ),
        this._onError(o=>{
            this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, o),
            this.state = xe.errored,
            this.rejoinTimer.scheduleTimeout())
        }
        ),
        this.joinPush.receive("timeout", ()=>{
            this._isJoining() && (this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout),
            this.state = xe.errored,
            this.rejoinTimer.scheduleTimeout())
        }
        ),
        this.joinPush.receive("error", o=>{
            this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, o),
            this.state = xe.errored,
            this.rejoinTimer.scheduleTimeout())
        }
        ),
        this._on(jt.reply, {}, (o,a)=>{
            this._trigger(this._replyEventName(a), o)
        }
        ),
        this.presence = new wi(this),
        this.broadcastEndpointURL = _y(this.socket.endPoint),
        this.private = this.params.config.private || !1,
        !this.private && (!((i = (s = this.params.config) === null || s === void 0 ? void 0 : s.broadcast) === null || i === void 0) && i.replay))
            throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`
    }
    subscribe(e, r=this.timeout) {
        var n, s, i;
        if (this.socket.isConnected() || this.socket.connect(),
        this.state == xe.closed) {
            const {config: {broadcast: o, presence: a, private: l}} = this.params
              , u = (s = (n = this.bindings.postgres_changes) === null || n === void 0 ? void 0 : n.map(d=>d.filter)) !== null && s !== void 0 ? s : []
              , c = !!this.bindings[bi.PRESENCE] && this.bindings[bi.PRESENCE].length > 0 || ((i = this.params.config.presence) === null || i === void 0 ? void 0 : i.enabled) === !0
              , h = {}
              , f = {
                broadcast: o,
                presence: Object.assign(Object.assign({}, a), {
                    enabled: c
                }),
                postgres_changes: u,
                private: l
            };
            this.socket.accessTokenValue && (h.access_token = this.socket.accessTokenValue),
            this._onError(d=>e == null ? void 0 : e(tr.CHANNEL_ERROR, d)),
            this._onClose(()=>e == null ? void 0 : e(tr.CLOSED)),
            this.updateJoinPayload(Object.assign({
                config: f
            }, h)),
            this.joinedOnce = !0,
            this._rejoin(r),
            this.joinPush.receive("ok", async({postgres_changes: d})=>{
                var y;
                if (this.socket.setAuth(),
                d === void 0) {
                    e == null || e(tr.SUBSCRIBED);
                    return
                } else {
                    const m = this.bindings.postgres_changes
                      , w = (y = m == null ? void 0 : m.length) !== null && y !== void 0 ? y : 0
                      , g = [];
                    for (let p = 0; p < w; p++) {
                        const v = m[p]
                          , {filter: {event: _, schema: E, table: S, filter: k}} = v
                          , P = d && d[p];
                        if (P && P.event === _ && P.schema === E && P.table === S && P.filter === k)
                            g.push(Object.assign(Object.assign({}, v), {
                                id: P.id
                            }));
                        else {
                            this.unsubscribe(),
                            this.state = xe.errored,
                            e == null || e(tr.CHANNEL_ERROR, new Error("mismatch between server and client bindings for postgres changes"));
                            return
                        }
                    }
                    this.bindings.postgres_changes = g,
                    e && e(tr.SUBSCRIBED);
                    return
                }
            }
            ).receive("error", d=>{
                this.state = xe.errored,
                e == null || e(tr.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(d).join(", ") || "error")))
            }
            ).receive("timeout", ()=>{
                e == null || e(tr.TIMED_OUT)
            }
            )
        }
        return this
    }
    presenceState() {
        return this.presence.state
    }
    async track(e, r={}) {
        return await this.send({
            type: "presence",
            event: "track",
            payload: e
        }, r.timeout || this.timeout)
    }
    async untrack(e={}) {
        return await this.send({
            type: "presence",
            event: "untrack"
        }, e)
    }
    on(e, r, n) {
        return this.state === xe.joined && e === bi.PRESENCE && (this.socket.log("channel", `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`),
        this.unsubscribe().then(()=>this.subscribe())),
        this._on(e, r, n)
    }
    async httpSend(e, r, n={}) {
        var s;
        const i = this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : "";
        if (r == null)
            return Promise.reject("Payload is required for httpSend()");
        const o = {
            method: "POST",
            headers: {
                Authorization: i,
                apikey: this.socket.apiKey ? this.socket.apiKey : "",
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                messages: [{
                    topic: this.subTopic,
                    event: e,
                    payload: r,
                    private: this.private
                }]
            })
        }
          , a = await this._fetchWithTimeout(this.broadcastEndpointURL, o, (s = n.timeout) !== null && s !== void 0 ? s : this.timeout);
        if (a.status === 202)
            return {
                success: !0
            };
        let l = a.statusText;
        try {
            const u = await a.json();
            l = u.error || u.message || l
        } catch {}
        return Promise.reject(new Error(l))
    }
    async send(e, r={}) {
        var n, s;
        if (!this._canPush() && e.type === "broadcast") {
            console.warn("Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.");
            const {event: i, payload: o} = e
              , l = {
                method: "POST",
                headers: {
                    Authorization: this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : "",
                    apikey: this.socket.apiKey ? this.socket.apiKey : "",
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    messages: [{
                        topic: this.subTopic,
                        event: i,
                        payload: o,
                        private: this.private
                    }]
                })
            };
            try {
                const u = await this._fetchWithTimeout(this.broadcastEndpointURL, l, (n = r.timeout) !== null && n !== void 0 ? n : this.timeout);
                return await ((s = u.body) === null || s === void 0 ? void 0 : s.cancel()),
                u.ok ? "ok" : "error"
            } catch (u) {
                return u.name === "AbortError" ? "timed out" : "error"
            }
        } else
            return new Promise(i=>{
                var o, a, l;
                const u = this._push(e.type, e, r.timeout || this.timeout);
                e.type === "broadcast" && !(!((l = (a = (o = this.params) === null || o === void 0 ? void 0 : o.config) === null || a === void 0 ? void 0 : a.broadcast) === null || l === void 0) && l.ack) && i("ok"),
                u.receive("ok", ()=>i("ok")),
                u.receive("error", ()=>i("error")),
                u.receive("timeout", ()=>i("timed out"))
            }
            )
    }
    updateJoinPayload(e) {
        this.joinPush.updatePayload(e)
    }
    unsubscribe(e=this.timeout) {
        this.state = xe.leaving;
        const r = ()=>{
            this.socket.log("channel", `leave ${this.topic}`),
            this._trigger(jt.close, "leave", this._joinRef())
        }
        ;
        this.joinPush.destroy();
        let n = null;
        return new Promise(s=>{
            n = new tu(this,jt.leave,{},e),
            n.receive("ok", ()=>{
                r(),
                s("ok")
            }
            ).receive("timeout", ()=>{
                r(),
                s("timed out")
            }
            ).receive("error", ()=>{
                s("error")
            }
            ),
            n.send(),
            this._canPush() || n.trigger("ok", {})
        }
        ).finally(()=>{
            n == null || n.destroy()
        }
        )
    }
    teardown() {
        this.pushBuffer.forEach(e=>e.destroy()),
        this.pushBuffer = [],
        this.rejoinTimer.reset(),
        this.joinPush.destroy(),
        this.state = xe.closed,
        this.bindings = {}
    }
    async _fetchWithTimeout(e, r, n) {
        const s = new AbortController
          , i = setTimeout(()=>s.abort(), n)
          , o = await this.socket.fetch(e, Object.assign(Object.assign({}, r), {
            signal: s.signal
        }));
        return clearTimeout(i),
        o
    }
    _push(e, r, n=this.timeout) {
        if (!this.joinedOnce)
            throw `tried to push '${e}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
        let s = new tu(this,e,r,n);
        return this._canPush() ? s.send() : this._addToPushBuffer(s),
        s
    }
    _addToPushBuffer(e) {
        if (e.startTimeout(),
        this.pushBuffer.push(e),
        this.pushBuffer.length > Xk) {
            const r = this.pushBuffer.shift();
            r && (r.destroy(),
            this.socket.log("channel", `discarded push due to buffer overflow: ${r.event}`, r.payload))
        }
    }
    _onMessage(e, r, n) {
        return r
    }
    _isMember(e) {
        return this.topic === e
    }
    _joinRef() {
        return this.joinPush.ref
    }
    _trigger(e, r, n) {
        var s, i;
        const o = e.toLocaleLowerCase()
          , {close: a, error: l, leave: u, join: c} = jt;
        if (n && [a, l, u, c].indexOf(o) >= 0 && n !== this._joinRef())
            return;
        let f = this._onMessage(o, r, n);
        if (r && !f)
            throw "channel onMessage callbacks must return the payload, modified or unmodified";
        ["insert", "update", "delete"].includes(o) ? (s = this.bindings.postgres_changes) === null || s === void 0 || s.filter(d=>{
            var y, m, w;
            return ((y = d.filter) === null || y === void 0 ? void 0 : y.event) === "*" || ((w = (m = d.filter) === null || m === void 0 ? void 0 : m.event) === null || w === void 0 ? void 0 : w.toLocaleLowerCase()) === o
        }
        ).map(d=>d.callback(f, n)) : (i = this.bindings[o]) === null || i === void 0 || i.filter(d=>{
            var y, m, w, g, p, v;
            if (["broadcast", "presence", "postgres_changes"].includes(o))
                if ("id"in d) {
                    const _ = d.id
                      , E = (y = d.filter) === null || y === void 0 ? void 0 : y.event;
                    return _ && ((m = r.ids) === null || m === void 0 ? void 0 : m.includes(_)) && (E === "*" || (E == null ? void 0 : E.toLocaleLowerCase()) === ((w = r.data) === null || w === void 0 ? void 0 : w.type.toLocaleLowerCase()))
                } else {
                    const _ = (p = (g = d == null ? void 0 : d.filter) === null || g === void 0 ? void 0 : g.event) === null || p === void 0 ? void 0 : p.toLocaleLowerCase();
                    return _ === "*" || _ === ((v = r == null ? void 0 : r.event) === null || v === void 0 ? void 0 : v.toLocaleLowerCase())
                }
            else
                return d.type.toLocaleLowerCase() === o
        }
        ).map(d=>{
            if (typeof f == "object" && "ids"in f) {
                const y = f.data
                  , {schema: m, table: w, commit_timestamp: g, type: p, errors: v} = y;
                f = Object.assign(Object.assign({}, {
                    schema: m,
                    table: w,
                    commit_timestamp: g,
                    eventType: p,
                    new: {},
                    old: {},
                    errors: v
                }), this._getPayloadRecords(y))
            }
            d.callback(f, n)
        }
        )
    }
    _isClosed() {
        return this.state === xe.closed
    }
    _isJoined() {
        return this.state === xe.joined
    }
    _isJoining() {
        return this.state === xe.joining
    }
    _isLeaving() {
        return this.state === xe.leaving
    }
    _replyEventName(e) {
        return `chan_reply_ ${e}`
    }
    _on(e, r, n) {
        const s = e.toLocaleLowerCase()
          , i = {
            type: s,
            filter: r,
            callback: n
        };
        return this.bindings[s] ? this.bindings[s].push(i) : this.bindings[s] = [i],
        this
    }
    _off(e, r) {
        const n = e.toLocaleLowerCase();
        return this.bindings[n] && (this.bindings[n] = this.bindings[n].filter(s=>{
            var i;
            return !(((i = s.type) === null || i === void 0 ? void 0 : i.toLocaleLowerCase()) === n && Kd.isEqual(s.filter, r))
        }
        )),
        this
    }
    static isEqual(e, r) {
        if (Object.keys(e).length !== Object.keys(r).length)
            return !1;
        for (const n in e)
            if (e[n] !== r[n])
                return !1;
        return !0
    }
    _rejoinUntilConnected() {
        this.rejoinTimer.scheduleTimeout(),
        this.socket.isConnected() && this._rejoin()
    }
    _onClose(e) {
        this._on(jt.close, {}, e)
    }
    _onError(e) {
        this._on(jt.error, {}, r=>e(r))
    }
    _canPush() {
        return this.socket.isConnected() && this._isJoined()
    }
    _rejoin(e=this.timeout) {
        this._isLeaving() || (this.socket._leaveOpenTopic(this.topic),
        this.state = xe.joining,
        this.joinPush.resend(e))
    }
    _getPayloadRecords(e) {
        const r = {
            new: {},
            old: {}
        };
        return (e.type === "INSERT" || e.type === "UPDATE") && (r.new = lp(e.columns, e.record)),
        (e.type === "UPDATE" || e.type === "DELETE") && (r.old = lp(e.columns, e.old_record)),
        r
    }
}
const ru = ()=>{}
  , Lo = {
    HEARTBEAT_INTERVAL: 25e3,
    RECONNECT_DELAY: 10,
    HEARTBEAT_TIMEOUT_FALLBACK: 100
}
  , oT = [1e3, 2e3, 5e3, 1e4]
  , aT = 1e4
  , lT = `
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;
class uT {
    constructor(e, r) {
        var n;
        if (this.accessTokenValue = null,
        this.apiKey = null,
        this.channels = new Array,
        this.endPoint = "",
        this.httpEndpoint = "",
        this.headers = {},
        this.params = {},
        this.timeout = _c,
        this.transport = null,
        this.heartbeatIntervalMs = Lo.HEARTBEAT_INTERVAL,
        this.heartbeatTimer = void 0,
        this.pendingHeartbeatRef = null,
        this.heartbeatCallback = ru,
        this.ref = 0,
        this.reconnectTimer = null,
        this.vsn = ap,
        this.logger = ru,
        this.conn = null,
        this.sendBuffer = [],
        this.serializer = new Zk,
        this.stateChangeCallbacks = {
            open: [],
            close: [],
            error: [],
            message: []
        },
        this.accessToken = null,
        this._connectionState = "disconnected",
        this._wasManualDisconnect = !1,
        this._authPromise = null,
        this._resolveFetch = s=>s ? (...i)=>s(...i) : (...i)=>fetch(...i),
        !(!((n = r == null ? void 0 : r.params) === null || n === void 0) && n.apikey))
            throw new Error("API key is required to connect to Realtime");
        this.apiKey = r.params.apikey,
        this.endPoint = `${e}/${xc.websocket}`,
        this.httpEndpoint = _y(e),
        this._initializeOptions(r),
        this._setupReconnectionTimer(),
        this.fetch = this._resolveFetch(r == null ? void 0 : r.fetch)
    }
    connect() {
        if (!(this.isConnecting() || this.isDisconnecting() || this.conn !== null && this.isConnected())) {
            if (this._setConnectionState("connecting"),
            this.accessToken && !this._authPromise && this._setAuthSafely("connect"),
            this.transport)
                this.conn = new this.transport(this.endpointURL());
            else
                try {
                    this.conn = Kk.createWebSocket(this.endpointURL())
                } catch (e) {
                    this._setConnectionState("disconnected");
                    const r = e.message;
                    throw r.includes("Node.js") ? new Error(`${r}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

  npm install ws

  import ws from "ws"
  const client = new RealtimeClient(url, {
    ...options,
    transport: ws
  })`) : new Error(`WebSocket not available: ${r}`)
                }
            this._setupConnectionHandlers()
        }
    }
    endpointURL() {
        return this._appendParams(this.endPoint, Object.assign({}, this.params, {
            vsn: this.vsn
        }))
    }
    disconnect(e, r) {
        if (!this.isDisconnecting())
            if (this._setConnectionState("disconnecting", !0),
            this.conn) {
                const n = setTimeout(()=>{
                    this._setConnectionState("disconnected")
                }
                , 100);
                this.conn.onclose = ()=>{
                    clearTimeout(n),
                    this._setConnectionState("disconnected")
                }
                ,
                typeof this.conn.close == "function" && (e ? this.conn.close(e, r ?? "") : this.conn.close()),
                this._teardownConnection()
            } else
                this._setConnectionState("disconnected")
    }
    getChannels() {
        return this.channels
    }
    async removeChannel(e) {
        const r = await e.unsubscribe();
        return this.channels.length === 0 && this.disconnect(),
        r
    }
    async removeAllChannels() {
        const e = await Promise.all(this.channels.map(r=>r.unsubscribe()));
        return this.channels = [],
        this.disconnect(),
        e
    }
    log(e, r, n) {
        this.logger(e, r, n)
    }
    connectionState() {
        switch (this.conn && this.conn.readyState) {
        case hn.connecting:
            return fn.Connecting;
        case hn.open:
            return fn.Open;
        case hn.closing:
            return fn.Closing;
        default:
            return fn.Closed
        }
    }
    isConnected() {
        return this.connectionState() === fn.Open
    }
    isConnecting() {
        return this._connectionState === "connecting"
    }
    isDisconnecting() {
        return this._connectionState === "disconnecting"
    }
    channel(e, r={
        config: {}
    }) {
        const n = `realtime:${e}`
          , s = this.getChannels().find(i=>i.topic === n);
        if (s)
            return s;
        {
            const i = new Kd(`realtime:${e}`,r,this);
            return this.channels.push(i),
            i
        }
    }
    push(e) {
        const {topic: r, event: n, payload: s, ref: i} = e
          , o = ()=>{
            this.encode(e, a=>{
                var l;
                (l = this.conn) === null || l === void 0 || l.send(a)
            }
            )
        }
        ;
        this.log("push", `${r} ${n} (${i})`, s),
        this.isConnected() ? o() : this.sendBuffer.push(o)
    }
    async setAuth(e=null) {
        this._authPromise = this._performAuth(e);
        try {
            await this._authPromise
        } finally {
            this._authPromise = null
        }
    }
    async sendHeartbeat() {
        var e;
        if (!this.isConnected()) {
            try {
                this.heartbeatCallback("disconnected")
            } catch (r) {
                this.log("error", "error in heartbeat callback", r)
            }
            return
        }
        if (this.pendingHeartbeatRef) {
            this.pendingHeartbeatRef = null,
            this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
            try {
                this.heartbeatCallback("timeout")
            } catch (r) {
                this.log("error", "error in heartbeat callback", r)
            }
            this._wasManualDisconnect = !1,
            (e = this.conn) === null || e === void 0 || e.close(Yk, "heartbeat timeout"),
            setTimeout(()=>{
                var r;
                this.isConnected() || (r = this.reconnectTimer) === null || r === void 0 || r.scheduleTimeout()
            }
            , Lo.HEARTBEAT_TIMEOUT_FALLBACK);
            return
        }
        this.pendingHeartbeatRef = this._makeRef(),
        this.push({
            topic: "phoenix",
            event: "heartbeat",
            payload: {},
            ref: this.pendingHeartbeatRef
        });
        try {
            this.heartbeatCallback("sent")
        } catch (r) {
            this.log("error", "error in heartbeat callback", r)
        }
        this._setAuthSafely("heartbeat")
    }
    onHeartbeat(e) {
        this.heartbeatCallback = e
    }
    flushSendBuffer() {
        this.isConnected() && this.sendBuffer.length > 0 && (this.sendBuffer.forEach(e=>e()),
        this.sendBuffer = [])
    }
    _makeRef() {
        let e = this.ref + 1;
        return e === this.ref ? this.ref = 0 : this.ref = e,
        this.ref.toString()
    }
    _leaveOpenTopic(e) {
        let r = this.channels.find(n=>n.topic === e && (n._isJoined() || n._isJoining()));
        r && (this.log("transport", `leaving duplicate topic "${e}"`),
        r.unsubscribe())
    }
    _remove(e) {
        this.channels = this.channels.filter(r=>r.topic !== e.topic)
    }
    _onConnMessage(e) {
        this.decode(e.data, r=>{
            if (r.topic === "phoenix" && r.event === "phx_reply")
                try {
                    this.heartbeatCallback(r.payload.status === "ok" ? "ok" : "error")
                } catch (u) {
                    this.log("error", "error in heartbeat callback", u)
                }
            r.ref && r.ref === this.pendingHeartbeatRef && (this.pendingHeartbeatRef = null);
            const {topic: n, event: s, payload: i, ref: o} = r
              , a = o ? `(${o})` : ""
              , l = i.status || "";
            this.log("receive", `${l} ${n} ${s} ${a}`.trim(), i),
            this.channels.filter(u=>u._isMember(n)).forEach(u=>u._trigger(s, i, o)),
            this._triggerStateCallbacks("message", r)
        }
        )
    }
    _clearTimer(e) {
        var r;
        e === "heartbeat" && this.heartbeatTimer ? (clearInterval(this.heartbeatTimer),
        this.heartbeatTimer = void 0) : e === "reconnect" && ((r = this.reconnectTimer) === null || r === void 0 || r.reset())
    }
    _clearAllTimers() {
        this._clearTimer("heartbeat"),
        this._clearTimer("reconnect")
    }
    _setupConnectionHandlers() {
        this.conn && ("binaryType"in this.conn && (this.conn.binaryType = "arraybuffer"),
        this.conn.onopen = ()=>this._onConnOpen(),
        this.conn.onerror = e=>this._onConnError(e),
        this.conn.onmessage = e=>this._onConnMessage(e),
        this.conn.onclose = e=>this._onConnClose(e))
    }
    _teardownConnection() {
        if (this.conn) {
            if (this.conn.readyState === hn.open || this.conn.readyState === hn.connecting)
                try {
                    this.conn.close()
                } catch (e) {
                    this.log("error", "Error closing connection", e)
                }
            this.conn.onopen = null,
            this.conn.onerror = null,
            this.conn.onmessage = null,
            this.conn.onclose = null,
            this.conn = null
        }
        this._clearAllTimers(),
        this.channels.forEach(e=>e.teardown())
    }
    _onConnOpen() {
        this._setConnectionState("connected"),
        this.log("transport", `connected to ${this.endpointURL()}`),
        (this._authPromise || (this.accessToken && !this.accessTokenValue ? this.setAuth() : Promise.resolve())).then(()=>{
            this.flushSendBuffer()
        }
        ).catch(r=>{
            this.log("error", "error waiting for auth on connect", r),
            this.flushSendBuffer()
        }
        ),
        this._clearTimer("reconnect"),
        this.worker ? this.workerRef || this._startWorkerHeartbeat() : this._startHeartbeat(),
        this._triggerStateCallbacks("open")
    }
    _startHeartbeat() {
        this.heartbeatTimer && clearInterval(this.heartbeatTimer),
        this.heartbeatTimer = setInterval(()=>this.sendHeartbeat(), this.heartbeatIntervalMs)
    }
    _startWorkerHeartbeat() {
        this.workerUrl ? this.log("worker", `starting worker for from ${this.workerUrl}`) : this.log("worker", "starting default worker");
        const e = this._workerObjectUrl(this.workerUrl);
        this.workerRef = new Worker(e),
        this.workerRef.onerror = r=>{
            this.log("worker", "worker error", r.message),
            this.workerRef.terminate()
        }
        ,
        this.workerRef.onmessage = r=>{
            r.data.event === "keepAlive" && this.sendHeartbeat()
        }
        ,
        this.workerRef.postMessage({
            event: "start",
            interval: this.heartbeatIntervalMs
        })
    }
    _onConnClose(e) {
        var r;
        this._setConnectionState("disconnected"),
        this.log("transport", "close", e),
        this._triggerChanError(),
        this._clearTimer("heartbeat"),
        this._wasManualDisconnect || (r = this.reconnectTimer) === null || r === void 0 || r.scheduleTimeout(),
        this._triggerStateCallbacks("close", e)
    }
    _onConnError(e) {
        this._setConnectionState("disconnected"),
        this.log("transport", `${e}`),
        this._triggerChanError(),
        this._triggerStateCallbacks("error", e)
    }
    _triggerChanError() {
        this.channels.forEach(e=>e._trigger(jt.error))
    }
    _appendParams(e, r) {
        if (Object.keys(r).length === 0)
            return e;
        const n = e.match(/\?/) ? "&" : "?"
          , s = new URLSearchParams(r);
        return `${e}${n}${s}`
    }
    _workerObjectUrl(e) {
        let r;
        if (e)
            r = e;
        else {
            const n = new Blob([lT],{
                type: "application/javascript"
            });
            r = URL.createObjectURL(n)
        }
        return r
    }
    _setConnectionState(e, r=!1) {
        this._connectionState = e,
        e === "connecting" ? this._wasManualDisconnect = !1 : e === "disconnecting" && (this._wasManualDisconnect = r)
    }
    async _performAuth(e=null) {
        let r;
        e ? r = e : this.accessToken ? r = await this.accessToken() : r = this.accessTokenValue,
        this.accessTokenValue != r && (this.accessTokenValue = r,
        this.channels.forEach(n=>{
            const s = {
                access_token: r,
                version: Qk
            };
            r && n.updateJoinPayload(s),
            n.joinedOnce && n._isJoined() && n._push(jt.access_token, {
                access_token: r
            })
        }
        ))
    }
    async _waitForAuthIfNeeded() {
        this._authPromise && await this._authPromise
    }
    _setAuthSafely(e="general") {
        this.setAuth().catch(r=>{
            this.log("error", `error setting auth in ${e}`, r)
        }
        )
    }
    _triggerStateCallbacks(e, r) {
        try {
            this.stateChangeCallbacks[e].forEach(n=>{
                try {
                    n(r)
                } catch (s) {
                    this.log("error", `error in ${e} callback`, s)
                }
            }
            )
        } catch (n) {
            this.log("error", `error triggering ${e} callbacks`, n)
        }
    }
    _setupReconnectionTimer() {
        this.reconnectTimer = new wy(async()=>{
            setTimeout(async()=>{
                await this._waitForAuthIfNeeded(),
                this.isConnected() || this.connect()
            }
            , Lo.RECONNECT_DELAY)
        }
        ,this.reconnectAfterMs)
    }
    _initializeOptions(e) {
        var r, n, s, i, o, a, l, u, c, h, f, d;
        switch (this.transport = (r = e == null ? void 0 : e.transport) !== null && r !== void 0 ? r : null,
        this.timeout = (n = e == null ? void 0 : e.timeout) !== null && n !== void 0 ? n : _c,
        this.heartbeatIntervalMs = (s = e == null ? void 0 : e.heartbeatIntervalMs) !== null && s !== void 0 ? s : Lo.HEARTBEAT_INTERVAL,
        this.worker = (i = e == null ? void 0 : e.worker) !== null && i !== void 0 ? i : !1,
        this.accessToken = (o = e == null ? void 0 : e.accessToken) !== null && o !== void 0 ? o : null,
        this.heartbeatCallback = (a = e == null ? void 0 : e.heartbeatCallback) !== null && a !== void 0 ? a : ru,
        this.vsn = (l = e == null ? void 0 : e.vsn) !== null && l !== void 0 ? l : ap,
        e != null && e.params && (this.params = e.params),
        e != null && e.logger && (this.logger = e.logger),
        (e != null && e.logLevel || e != null && e.log_level) && (this.logLevel = e.logLevel || e.log_level,
        this.params = Object.assign(Object.assign({}, this.params), {
            log_level: this.logLevel
        })),
        this.reconnectAfterMs = (u = e == null ? void 0 : e.reconnectAfterMs) !== null && u !== void 0 ? u : y=>oT[y - 1] || aT,
        this.vsn) {
        case yy:
            this.encode = (c = e == null ? void 0 : e.encode) !== null && c !== void 0 ? c : (y,m)=>m(JSON.stringify(y)),
            this.decode = (h = e == null ? void 0 : e.decode) !== null && h !== void 0 ? h : (y,m)=>m(JSON.parse(y));
            break;
        case Jk:
            this.encode = (f = e == null ? void 0 : e.encode) !== null && f !== void 0 ? f : this.serializer.encode.bind(this.serializer),
            this.decode = (d = e == null ? void 0 : e.decode) !== null && d !== void 0 ? d : this.serializer.decode.bind(this.serializer);
            break;
        default:
            throw new Error(`Unsupported serializer version: ${this.vsn}`)
        }
        if (this.worker) {
            if (typeof window < "u" && !window.Worker)
                throw new Error("Web Worker is not supported");
            this.workerUrl = e == null ? void 0 : e.workerUrl
        }
    }
}
class ml extends Error {
    constructor(e) {
        super(e),
        this.__isStorageError = !0,
        this.name = "StorageError"
    }
}
function he(t) {
    return typeof t == "object" && t !== null && "__isStorageError"in t
}
class cT extends ml {
    constructor(e, r, n) {
        super(e),
        this.name = "StorageApiError",
        this.status = r,
        this.statusCode = n
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            status: this.status,
            statusCode: this.statusCode
        }
    }
}
class Sc extends ml {
    constructor(e, r) {
        super(e),
        this.name = "StorageUnknownError",
        this.originalError = r
    }
}
const Gd = t=>t ? (...e)=>t(...e) : (...e)=>fetch(...e)
  , dT = ()=>Response
  , kc = t=>{
    if (Array.isArray(t))
        return t.map(r=>kc(r));
    if (typeof t == "function" || t !== Object(t))
        return t;
    const e = {};
    return Object.entries(t).forEach(([r,n])=>{
        const s = r.replace(/([-_][a-z])/gi, i=>i.toUpperCase().replace(/[-_]/g, ""));
        e[s] = kc(n)
    }
    ),
    e
}
  , hT = t=>{
    if (typeof t != "object" || t === null)
        return !1;
    const e = Object.getPrototypeOf(t);
    return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t)
}
  , fT = t=>!t || typeof t != "string" || t.length === 0 || t.length > 100 || t.trim() !== t || t.includes("/") || t.includes("\\") ? !1 : /^[\w!.\*'() &$@=;:+,?-]+$/.test(t)
  , nu = t=>{
    var e;
    return t.msg || t.message || t.error_description || (typeof t.error == "string" ? t.error : (e = t.error) === null || e === void 0 ? void 0 : e.message) || JSON.stringify(t)
}
  , pT = (t,e,r)=>U(void 0, void 0, void 0, function*() {
    const n = yield dT();
    t instanceof n && !(r != null && r.noResolveJson) ? t.json().then(s=>{
        const i = t.status || 500
          , o = (s == null ? void 0 : s.statusCode) || i + "";
        e(new cT(nu(s),i,o))
    }
    ).catch(s=>{
        e(new Sc(nu(s),s))
    }
    ) : e(new Sc(nu(t),t))
})
  , mT = (t,e,r,n)=>{
    const s = {
        method: t,
        headers: (e == null ? void 0 : e.headers) || {}
    };
    return t === "GET" || !n ? s : (hT(n) ? (s.headers = Object.assign({
        "Content-Type": "application/json"
    }, e == null ? void 0 : e.headers),
    s.body = JSON.stringify(n)) : s.body = n,
    e != null && e.duplex && (s.duplex = e.duplex),
    Object.assign(Object.assign({}, s), r))
}
;
function ro(t, e, r, n, s, i) {
    return U(this, void 0, void 0, function*() {
        return new Promise((o,a)=>{
            t(r, mT(e, n, s, i)).then(l=>{
                if (!l.ok)
                    throw l;
                return n != null && n.noResolveJson ? l : l.json()
            }
            ).then(l=>o(l)).catch(l=>pT(l, a, n))
        }
        )
    })
}
function zi(t, e, r, n) {
    return U(this, void 0, void 0, function*() {
        return ro(t, "GET", e, r, n)
    })
}
function Ct(t, e, r, n, s) {
    return U(this, void 0, void 0, function*() {
        return ro(t, "POST", e, n, s, r)
    })
}
function Tc(t, e, r, n, s) {
    return U(this, void 0, void 0, function*() {
        return ro(t, "PUT", e, n, s, r)
    })
}
function gT(t, e, r, n) {
    return U(this, void 0, void 0, function*() {
        return ro(t, "HEAD", e, Object.assign(Object.assign({}, r), {
            noResolveJson: !0
        }), n)
    })
}
function Qd(t, e, r, n, s) {
    return U(this, void 0, void 0, function*() {
        return ro(t, "DELETE", e, n, s, r)
    })
}
class vT {
    constructor(e, r) {
        this.downloadFn = e,
        this.shouldThrowOnError = r
    }
    then(e, r) {
        return this.execute().then(e, r)
    }
    execute() {
        return U(this, void 0, void 0, function*() {
            try {
                return {
                    data: (yield this.downloadFn()).body,
                    error: null
                }
            } catch (e) {
                if (this.shouldThrowOnError)
                    throw e;
                if (he(e))
                    return {
                        data: null,
                        error: e
                    };
                throw e
            }
        })
    }
}
var xy;
class yT {
    constructor(e, r) {
        this.downloadFn = e,
        this.shouldThrowOnError = r,
        this[xy] = "BlobDownloadBuilder",
        this.promise = null
    }
    asStream() {
        return new vT(this.downloadFn,this.shouldThrowOnError)
    }
    then(e, r) {
        return this.getPromise().then(e, r)
    }
    catch(e) {
        return this.getPromise().catch(e)
    }
    finally(e) {
        return this.getPromise().finally(e)
    }
    getPromise() {
        return this.promise || (this.promise = this.execute()),
        this.promise
    }
    execute() {
        return U(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield(yield this.downloadFn()).blob(),
                    error: null
                }
            } catch (e) {
                if (this.shouldThrowOnError)
                    throw e;
                if (he(e))
                    return {
                        data: null,
                        error: e
                    };
                throw e
            }
        })
    }
}
xy = Symbol.toStringTag;
const wT = {
    limit: 100,
    offset: 0,
    sortBy: {
        column: "name",
        order: "asc"
    }
}
  , dp = {
    cacheControl: "3600",
    contentType: "text/plain;charset=UTF-8",
    upsert: !1
};
class bT {
    constructor(e, r={}, n, s) {
        this.shouldThrowOnError = !1,
        this.url = e,
        this.headers = r,
        this.bucketId = n,
        this.fetch = Gd(s)
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    uploadOrUpdate(e, r, n, s) {
        return U(this, void 0, void 0, function*() {
            try {
                let i;
                const o = Object.assign(Object.assign({}, dp), s);
                let a = Object.assign(Object.assign({}, this.headers), e === "POST" && {
                    "x-upsert": String(o.upsert)
                });
                const l = o.metadata;
                typeof Blob < "u" && n instanceof Blob ? (i = new FormData,
                i.append("cacheControl", o.cacheControl),
                l && i.append("metadata", this.encodeMetadata(l)),
                i.append("", n)) : typeof FormData < "u" && n instanceof FormData ? (i = n,
                i.has("cacheControl") || i.append("cacheControl", o.cacheControl),
                l && !i.has("metadata") && i.append("metadata", this.encodeMetadata(l))) : (i = n,
                a["cache-control"] = `max-age=${o.cacheControl}`,
                a["content-type"] = o.contentType,
                l && (a["x-metadata"] = this.toBase64(this.encodeMetadata(l))),
                (typeof ReadableStream < "u" && i instanceof ReadableStream || i && typeof i == "object" && "pipe"in i && typeof i.pipe == "function") && !o.duplex && (o.duplex = "half")),
                s != null && s.headers && (a = Object.assign(Object.assign({}, a), s.headers));
                const u = this._removeEmptyFolders(r)
                  , c = this._getFinalPath(u)
                  , h = yield(e == "PUT" ? Tc : Ct)(this.fetch, `${this.url}/object/${c}`, i, Object.assign({
                    headers: a
                }, o != null && o.duplex ? {
                    duplex: o.duplex
                } : {}));
                return {
                    data: {
                        path: u,
                        id: h.Id,
                        fullPath: h.Key
                    },
                    error: null
                }
            } catch (i) {
                if (this.shouldThrowOnError)
                    throw i;
                if (he(i))
                    return {
                        data: null,
                        error: i
                    };
                throw i
            }
        })
    }
    upload(e, r, n) {
        return U(this, void 0, void 0, function*() {
            return this.uploadOrUpdate("POST", e, r, n)
        })
    }
    uploadToSignedUrl(e, r, n, s) {
        return U(this, void 0, void 0, function*() {
            const i = this._removeEmptyFolders(e)
              , o = this._getFinalPath(i)
              , a = new URL(this.url + `/object/upload/sign/${o}`);
            a.searchParams.set("token", r);
            try {
                let l;
                const u = Object.assign({
                    upsert: dp.upsert
                }, s)
                  , c = Object.assign(Object.assign({}, this.headers), {
                    "x-upsert": String(u.upsert)
                });
                typeof Blob < "u" && n instanceof Blob ? (l = new FormData,
                l.append("cacheControl", u.cacheControl),
                l.append("", n)) : typeof FormData < "u" && n instanceof FormData ? (l = n,
                l.append("cacheControl", u.cacheControl)) : (l = n,
                c["cache-control"] = `max-age=${u.cacheControl}`,
                c["content-type"] = u.contentType);
                const h = yield Tc(this.fetch, a.toString(), l, {
                    headers: c
                });
                return {
                    data: {
                        path: i,
                        fullPath: h.Key
                    },
                    error: null
                }
            } catch (l) {
                if (this.shouldThrowOnError)
                    throw l;
                if (he(l))
                    return {
                        data: null,
                        error: l
                    };
                throw l
            }
        })
    }
    createSignedUploadUrl(e, r) {
        return U(this, void 0, void 0, function*() {
            try {
                let n = this._getFinalPath(e);
                const s = Object.assign({}, this.headers);
                r != null && r.upsert && (s["x-upsert"] = "true");
                const i = yield Ct(this.fetch, `${this.url}/object/upload/sign/${n}`, {}, {
                    headers: s
                })
                  , o = new URL(this.url + i.url)
                  , a = o.searchParams.get("token");
                if (!a)
                    throw new ml("No token returned by API");
                return {
                    data: {
                        signedUrl: o.toString(),
                        path: e,
                        token: a
                    },
                    error: null
                }
            } catch (n) {
                if (this.shouldThrowOnError)
                    throw n;
                if (he(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        })
    }
    update(e, r, n) {
        return U(this, void 0, void 0, function*() {
            return this.uploadOrUpdate("PUT", e, r, n)
        })
    }
    move(e, r, n) {
        return U(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield Ct(this.fetch, `${this.url}/object/move`, {
                        bucketId: this.bucketId,
                        sourceKey: e,
                        destinationKey: r,
                        destinationBucket: n == null ? void 0 : n.destinationBucket
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (s) {
                if (this.shouldThrowOnError)
                    throw s;
                if (he(s))
                    return {
                        data: null,
                        error: s
                    };
                throw s
            }
        })
    }
    copy(e, r, n) {
        return U(this, void 0, void 0, function*() {
            try {
                return {
                    data: {
                        path: (yield Ct(this.fetch, `${this.url}/object/copy`, {
                            bucketId: this.bucketId,
                            sourceKey: e,
                            destinationKey: r,
                            destinationBucket: n == null ? void 0 : n.destinationBucket
                        }, {
                            headers: this.headers
                        })).Key
                    },
                    error: null
                }
            } catch (s) {
                if (this.shouldThrowOnError)
                    throw s;
                if (he(s))
                    return {
                        data: null,
                        error: s
                    };
                throw s
            }
        })
    }
    createSignedUrl(e, r, n) {
        return U(this, void 0, void 0, function*() {
            try {
                let s = this._getFinalPath(e)
                  , i = yield Ct(this.fetch, `${this.url}/object/sign/${s}`, Object.assign({
                    expiresIn: r
                }, n != null && n.transform ? {
                    transform: n.transform
                } : {}), {
                    headers: this.headers
                });
                const o = n != null && n.download ? `&download=${n.download === !0 ? "" : n.download}` : "";
                return i = {
                    signedUrl: encodeURI(`${this.url}${i.signedURL}${o}`)
                },
                {
                    data: i,
                    error: null
                }
            } catch (s) {
                if (this.shouldThrowOnError)
                    throw s;
                if (he(s))
                    return {
                        data: null,
                        error: s
                    };
                throw s
            }
        })
    }
    createSignedUrls(e, r, n) {
        return U(this, void 0, void 0, function*() {
            try {
                const s = yield Ct(this.fetch, `${this.url}/object/sign/${this.bucketId}`, {
                    expiresIn: r,
                    paths: e
                }, {
                    headers: this.headers
                })
                  , i = n != null && n.download ? `&download=${n.download === !0 ? "" : n.download}` : "";
                return {
                    data: s.map(o=>Object.assign(Object.assign({}, o), {
                        signedUrl: o.signedURL ? encodeURI(`${this.url}${o.signedURL}${i}`) : null
                    })),
                    error: null
                }
            } catch (s) {
                if (this.shouldThrowOnError)
                    throw s;
                if (he(s))
                    return {
                        data: null,
                        error: s
                    };
                throw s
            }
        })
    }
    download(e, r) {
        const s = typeof (r == null ? void 0 : r.transform) < "u" ? "render/image/authenticated" : "object"
          , i = this.transformOptsToQueryString((r == null ? void 0 : r.transform) || {})
          , o = i ? `?${i}` : ""
          , a = this._getFinalPath(e)
          , l = ()=>zi(this.fetch, `${this.url}/${s}/${a}${o}`, {
            headers: this.headers,
            noResolveJson: !0
        });
        return new yT(l,this.shouldThrowOnError)
    }
    info(e) {
        return U(this, void 0, void 0, function*() {
            const r = this._getFinalPath(e);
            try {
                const n = yield zi(this.fetch, `${this.url}/object/info/${r}`, {
                    headers: this.headers
                });
                return {
                    data: kc(n),
                    error: null
                }
            } catch (n) {
                if (this.shouldThrowOnError)
                    throw n;
                if (he(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        })
    }
    exists(e) {
        return U(this, void 0, void 0, function*() {
            const r = this._getFinalPath(e);
            try {
                return yield gT(this.fetch, `${this.url}/object/${r}`, {
                    headers: this.headers
                }),
                {
                    data: !0,
                    error: null
                }
            } catch (n) {
                if (this.shouldThrowOnError)
                    throw n;
                if (he(n) && n instanceof Sc) {
                    const s = n.originalError;
                    if ([400, 404].includes(s == null ? void 0 : s.status))
                        return {
                            data: !1,
                            error: n
                        }
                }
                throw n
            }
        })
    }
    getPublicUrl(e, r) {
        const n = this._getFinalPath(e)
          , s = []
          , i = r != null && r.download ? `download=${r.download === !0 ? "" : r.download}` : "";
        i !== "" && s.push(i);
        const a = typeof (r == null ? void 0 : r.transform) < "u" ? "render/image" : "object"
          , l = this.transformOptsToQueryString((r == null ? void 0 : r.transform) || {});
        l !== "" && s.push(l);
        let u = s.join("&");
        return u !== "" && (u = `?${u}`),
        {
            data: {
                publicUrl: encodeURI(`${this.url}/${a}/public/${n}${u}`)
            }
        }
    }
    remove(e) {
        return U(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield Qd(this.fetch, `${this.url}/object/${this.bucketId}`, {
                        prefixes: e
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (he(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    list(e, r, n) {
        return U(this, void 0, void 0, function*() {
            try {
                const s = Object.assign(Object.assign(Object.assign({}, wT), r), {
                    prefix: e || ""
                });
                return {
                    data: yield Ct(this.fetch, `${this.url}/object/list/${this.bucketId}`, s, {
                        headers: this.headers
                    }, n),
                    error: null
                }
            } catch (s) {
                if (this.shouldThrowOnError)
                    throw s;
                if (he(s))
                    return {
                        data: null,
                        error: s
                    };
                throw s
            }
        })
    }
    listV2(e, r) {
        return U(this, void 0, void 0, function*() {
            try {
                const n = Object.assign({}, e);
                return {
                    data: yield Ct(this.fetch, `${this.url}/object/list-v2/${this.bucketId}`, n, {
                        headers: this.headers
                    }, r),
                    error: null
                }
            } catch (n) {
                if (this.shouldThrowOnError)
                    throw n;
                if (he(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        })
    }
    encodeMetadata(e) {
        return JSON.stringify(e)
    }
    toBase64(e) {
        return typeof Buffer < "u" ? Buffer.from(e).toString("base64") : btoa(e)
    }
    _getFinalPath(e) {
        return `${this.bucketId}/${e.replace(/^\/+/, "")}`
    }
    _removeEmptyFolders(e) {
        return e.replace(/^\/|\/$/g, "").replace(/\/+/g, "/")
    }
    transformOptsToQueryString(e) {
        const r = [];
        return e.width && r.push(`width=${e.width}`),
        e.height && r.push(`height=${e.height}`),
        e.resize && r.push(`resize=${e.resize}`),
        e.format && r.push(`format=${e.format}`),
        e.quality && r.push(`quality=${e.quality}`),
        r.join("&")
    }
}
const Ey = "2.86.0"
  , Sy = {
    "X-Client-Info": `storage-js/${Ey}`
};
class _T {
    constructor(e, r={}, n, s) {
        this.shouldThrowOnError = !1;
        const i = new URL(e);
        s != null && s.useNewHostname && /supabase\.(co|in|red)$/.test(i.hostname) && !i.hostname.includes("storage.supabase.") && (i.hostname = i.hostname.replace("supabase.", "storage.supabase.")),
        this.url = i.href.replace(/\/$/, ""),
        this.headers = Object.assign(Object.assign({}, Sy), r),
        this.fetch = Gd(n)
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    listBuckets(e) {
        return U(this, void 0, void 0, function*() {
            try {
                const r = this.listBucketOptionsToQueryString(e);
                return {
                    data: yield zi(this.fetch, `${this.url}/bucket ${r}`, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (he(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    getBucket(e) {
        return U(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield zi(this.fetch, `${this.url}/bucket/${e}`, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (he(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    createBucket(e) {
        return U(this, arguments, void 0, function*(r, n={
            public: !1
        }) {
            try {
                return {
                    data: yield Ct(this.fetch, `${this.url}/bucket`, {
                        id: r,
                        name: r,
                        type: n.type,
                        public: n.public,
                        file_size_limit: n.fileSizeLimit,
                        allowed_mime_types: n.allowedMimeTypes
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (s) {
                if (this.shouldThrowOnError)
                    throw s;
                if (he(s))
                    return {
                        data: null,
                        error: s
                    };
                throw s
            }
        })
    }
    updateBucket(e, r) {
        return U(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield Tc(this.fetch, `${this.url}/bucket/${e}`, {
                        id: e,
                        name: e,
                        public: r.public,
                        file_size_limit: r.fileSizeLimit,
                        allowed_mime_types: r.allowedMimeTypes
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (n) {
                if (this.shouldThrowOnError)
                    throw n;
                if (he(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        })
    }
    emptyBucket(e) {
        return U(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield Ct(this.fetch, `${this.url}/bucket/${e}/empty`, {}, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (he(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    deleteBucket(e) {
        return U(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield Qd(this.fetch, `${this.url}/bucket/${e}`, {}, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (he(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    listBucketOptionsToQueryString(e) {
        const r = {};
        return e && ("limit"in e && (r.limit = String(e.limit)),
        "offset"in e && (r.offset = String(e.offset)),
        e.search && (r.search = e.search),
        e.sortColumn && (r.sortColumn = e.sortColumn),
        e.sortOrder && (r.sortOrder = e.sortOrder)),
        Object.keys(r).length > 0 ? "?" + new URLSearchParams(r).toString() : ""
    }
}
var Vi = class extends Error {
    constructor(t, e) {
        var r;
        super(t),
        this.name = "IcebergError",
        this.status = e.status,
        this.icebergType = e.icebergType,
        this.icebergCode = e.icebergCode,
        this.details = e.details,
        this.isCommitStateUnknown = e.icebergType === "CommitStateUnknownException" || [500, 502, 504].includes(e.status) && ((r = e.icebergType) == null ? void 0 : r.includes("CommitState")) === !0
    }
    isNotFound() {
        return this.status === 404
    }
    isConflict() {
        return this.status === 409
    }
    isAuthenticationTimeout() {
        return this.status === 419
    }
}
;
function xT(t, e, r) {
    const n = new URL(e,t);
    if (r)
        for (const [s,i] of Object.entries(r))
            i !== void 0 && n.searchParams.set(s, i);
    return n.toString()
}
async function ET(t) {
    return !t || t.type === "none" ? {} : t.type === "bearer" ? {
        Authorization: `Bearer ${t.token}`
    } : t.type === "header" ? {
        [t.name]: t.value
    } : t.type === "custom" ? await t.getHeaders() : {}
}
function ST(t) {
    const e = t.fetchImpl ?? globalThis.fetch;
    return {
        async request({method: r, path: n, query: s, body: i, headers: o}) {
            const a = xT(t.baseUrl, n, s)
              , l = await ET(t.auth)
              , u = await e(a, {
                method: r,
                headers: {
                    ...i ? {
                        "Content-Type": "application/json"
                    } : {},
                    ...l,
                    ...o
                },
                body: i ? JSON.stringify(i) : void 0
            })
              , c = await u.text()
              , h = (u.headers.get("content-type") || "").includes("application/json")
              , f = h && c ? JSON.parse(c) : c;
            if (!u.ok) {
                const d = h ? f : void 0
                  , y = d == null ? void 0 : d.error;
                throw new Vi((y == null ? void 0 : y.message) ?? `Request failed with status ${u.status}`,{
                    status: u.status,
                    icebergType: y == null ? void 0 : y.type,
                    icebergCode: y == null ? void 0 : y.code,
                    details: d
                })
            }
            return {
                status: u.status,
                headers: u.headers,
                data: f
            }
        }
    }
}
function Uo(t) {
    return t.join("")
}
var kT = class {
    constructor(t, e="") {
        this.client = t,
        this.prefix = e
    }
    async listNamespaces(t) {
        const e = t ? {
            parent: Uo(t.namespace)
        } : void 0;
        return (await this.client.request({
            method: "GET",
            path: `${this.prefix}/namespaces`,
            query: e
        })).data.namespaces.map(n=>({
            namespace: n
        }))
    }
    async createNamespace(t, e) {
        const r = {
            namespace: t.namespace,
            properties: e == null ? void 0 : e.properties
        };
        return (await this.client.request({
            method: "POST",
            path: `${this.prefix}/namespaces`,
            body: r
        })).data
    }
    async dropNamespace(t) {
        await this.client.request({
            method: "DELETE",
            path: `${this.prefix}/namespaces/${Uo(t.namespace)}`
        })
    }
    async loadNamespaceMetadata(t) {
        return {
            properties: (await this.client.request({
                method: "GET",
                path: `${this.prefix}/namespaces/${Uo(t.namespace)}`
            })).data.properties
        }
    }
    async namespaceExists(t) {
        try {
            return await this.client.request({
                method: "HEAD",
                path: `${this.prefix}/namespaces/${Uo(t.namespace)}`
            }),
            !0
        } catch (e) {
            if (e instanceof Vi && e.status === 404)
                return !1;
            throw e
        }
    }
    async createNamespaceIfNotExists(t, e) {
        try {
            return await this.createNamespace(t, e)
        } catch (r) {
            if (r instanceof Vi && r.status === 409)
                return;
            throw r
        }
    }
}
;
function zn(t) {
    return t.join("")
}
var TT = class {
    constructor(t, e="", r) {
        this.client = t,
        this.prefix = e,
        this.accessDelegation = r
    }
    async listTables(t) {
        return (await this.client.request({
            method: "GET",
            path: `${this.prefix}/namespaces/${zn(t.namespace)}/tables`
        })).data.identifiers
    }
    async createTable(t, e) {
        const r = {};
        return this.accessDelegation && (r["X-Iceberg-Access-Delegation"] = this.accessDelegation),
        (await this.client.request({
            method: "POST",
            path: `${this.prefix}/namespaces/${zn(t.namespace)}/tables`,
            body: e,
            headers: r
        })).data.metadata
    }
    async updateTable(t, e) {
        const r = await this.client.request({
            method: "POST",
            path: `${this.prefix}/namespaces/${zn(t.namespace)}/tables/${t.name}`,
            body: e
        });
        return {
            "metadata-location": r.data["metadata-location"],
            metadata: r.data.metadata
        }
    }
    async dropTable(t, e) {
        await this.client.request({
            method: "DELETE",
            path: `${this.prefix}/namespaces/${zn(t.namespace)}/tables/${t.name}`,
            query: {
                purgeRequested: String((e == null ? void 0 : e.purge) ?? !1)
            }
        })
    }
    async loadTable(t) {
        const e = {};
        return this.accessDelegation && (e["X-Iceberg-Access-Delegation"] = this.accessDelegation),
        (await this.client.request({
            method: "GET",
            path: `${this.prefix}/namespaces/${zn(t.namespace)}/tables/${t.name}`,
            headers: e
        })).data.metadata
    }
    async tableExists(t) {
        const e = {};
        this.accessDelegation && (e["X-Iceberg-Access-Delegation"] = this.accessDelegation);
        try {
            return await this.client.request({
                method: "HEAD",
                path: `${this.prefix}/namespaces/${zn(t.namespace)}/tables/${t.name}`,
                headers: e
            }),
            !0
        } catch (r) {
            if (r instanceof Vi && r.status === 404)
                return !1;
            throw r
        }
    }
    async createTableIfNotExists(t, e) {
        try {
            return await this.createTable(t, e)
        } catch (r) {
            if (r instanceof Vi && r.status === 409)
                return await this.loadTable({
                    namespace: t.namespace,
                    name: e.name
                });
            throw r
        }
    }
}
  , CT = class {
    constructor(t) {
        var n;
        let e = "v1";
        t.catalogName && (e += `/${t.catalogName}`);
        const r = t.baseUrl.endsWith("/") ? t.baseUrl : `${t.baseUrl}/`;
        this.client = ST({
            baseUrl: r,
            auth: t.auth,
            fetchImpl: t.fetch
        }),
        this.accessDelegation = (n = t.accessDelegation) == null ? void 0 : n.join(","),
        this.namespaceOps = new kT(this.client,e),
        this.tableOps = new TT(this.client,e,this.accessDelegation)
    }
    async listNamespaces(t) {
        return this.namespaceOps.listNamespaces(t)
    }
    async createNamespace(t, e) {
        return this.namespaceOps.createNamespace(t, e)
    }
    async dropNamespace(t) {
        await this.namespaceOps.dropNamespace(t)
    }
    async loadNamespaceMetadata(t) {
        return this.namespaceOps.loadNamespaceMetadata(t)
    }
    async listTables(t) {
        return this.tableOps.listTables(t)
    }
    async createTable(t, e) {
        return this.tableOps.createTable(t, e)
    }
    async updateTable(t, e) {
        return this.tableOps.updateTable(t, e)
    }
    async dropTable(t, e) {
        await this.tableOps.dropTable(t, e)
    }
    async loadTable(t) {
        return this.tableOps.loadTable(t)
    }
    async namespaceExists(t) {
        return this.namespaceOps.namespaceExists(t)
    }
    async tableExists(t) {
        return this.tableOps.tableExists(t)
    }
    async createNamespaceIfNotExists(t, e) {
        return this.namespaceOps.createNamespaceIfNotExists(t, e)
    }
    async createTableIfNotExists(t, e) {
        return this.tableOps.createTableIfNotExists(t, e)
    }
}
;
class PT {
    constructor(e, r={}, n) {
        this.shouldThrowOnError = !1,
        this.url = e.replace(/\/$/, ""),
        this.headers = Object.assign(Object.assign({}, Sy), r),
        this.fetch = Gd(n)
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    createBucket(e) {
        return U(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield Ct(this.fetch, `${this.url}/bucket`, {
                        name: e
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (he(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    listBuckets(e) {
        return U(this, void 0, void 0, function*() {
            try {
                const r = new URLSearchParams;
                (e == null ? void 0 : e.limit) !== void 0 && r.set("limit", e.limit.toString()),
                (e == null ? void 0 : e.offset) !== void 0 && r.set("offset", e.offset.toString()),
                e != null && e.sortColumn && r.set("sortColumn", e.sortColumn),
                e != null && e.sortOrder && r.set("sortOrder", e.sortOrder),
                e != null && e.search && r.set("search", e.search);
                const n = r.toString()
                  , s = n ? `${this.url}/bucket?${n}` : `${this.url}/bucket`;
                return {
                    data: yield zi(this.fetch, s, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (he(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    deleteBucket(e) {
        return U(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield Qd(this.fetch, `${this.url}/bucket/${e}`, {}, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (he(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    from(e) {
        if (!fT(e))
            throw new ml("Invalid bucket name: File, folder, and bucket names must follow AWS object key naming guidelines and should avoid the use of any other characters.");
        return new CT({
            baseUrl: this.url,
            catalogName: e,
            auth: {
                type: "custom",
                getHeaders: ()=>U(this, void 0, void 0, function*() {
                    return this.headers
                })
            },
            fetch: this.fetch
        })
    }
}
const Jd = {
    "X-Client-Info": `storage-js/${Ey}`,
    "Content-Type": "application/json"
};
class ky extends Error {
    constructor(e) {
        super(e),
        this.__isStorageVectorsError = !0,
        this.name = "StorageVectorsError"
    }
}
function nt(t) {
    return typeof t == "object" && t !== null && "__isStorageVectorsError"in t
}
class su extends ky {
    constructor(e, r, n) {
        super(e),
        this.name = "StorageVectorsApiError",
        this.status = r,
        this.statusCode = n
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            status: this.status,
            statusCode: this.statusCode
        }
    }
}
class OT extends ky {
    constructor(e, r) {
        super(e),
        this.name = "StorageVectorsUnknownError",
        this.originalError = r
    }
}
var hp;
(function(t) {
    t.InternalError = "InternalError",
    t.S3VectorConflictException = "S3VectorConflictException",
    t.S3VectorNotFoundException = "S3VectorNotFoundException",
    t.S3VectorBucketNotEmpty = "S3VectorBucketNotEmpty",
    t.S3VectorMaxBucketsExceeded = "S3VectorMaxBucketsExceeded",
    t.S3VectorMaxIndexesExceeded = "S3VectorMaxIndexesExceeded"
}
)(hp || (hp = {}));
const Yd = t=>t ? (...e)=>t(...e) : (...e)=>fetch(...e)
  , RT = t=>{
    if (typeof t != "object" || t === null)
        return !1;
    const e = Object.getPrototypeOf(t);
    return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t)
}
  , fp = t=>t.msg || t.message || t.error_description || t.error || JSON.stringify(t)
  , jT = (t,e,r)=>U(void 0, void 0, void 0, function*() {
    if (t && typeof t == "object" && "status"in t && "ok"in t && typeof t.status == "number" && !(r != null && r.noResolveJson)) {
        const s = t.status || 500
          , i = t;
        if (typeof i.json == "function")
            i.json().then(o=>{
                const a = (o == null ? void 0 : o.statusCode) || (o == null ? void 0 : o.code) || s + "";
                e(new su(fp(o),s,a))
            }
            ).catch(()=>{
                const o = s + ""
                  , a = i.statusText || `HTTP ${s} error`;
                e(new su(a,s,o))
            }
            );
        else {
            const o = s + ""
              , a = i.statusText || `HTTP ${s} error`;
            e(new su(a,s,o))
        }
    } else
        e(new OT(fp(t),t))
})
  , AT = (t,e,r,n)=>{
    const s = {
        method: t,
        headers: (e == null ? void 0 : e.headers) || {}
    };
    return n ? (RT(n) ? (s.headers = Object.assign({
        "Content-Type": "application/json"
    }, e == null ? void 0 : e.headers),
    s.body = JSON.stringify(n)) : s.body = n,
    Object.assign(Object.assign({}, s), r)) : s
}
;
function NT(t, e, r, n, s, i) {
    return U(this, void 0, void 0, function*() {
        return new Promise((o,a)=>{
            t(r, AT(e, n, s, i)).then(l=>{
                if (!l.ok)
                    throw l;
                if (n != null && n.noResolveJson)
                    return l;
                const u = l.headers.get("content-type");
                return !u || !u.includes("application/json") ? {} : l.json()
            }
            ).then(l=>o(l)).catch(l=>jT(l, a, n))
        }
        )
    })
}
function st(t, e, r, n, s) {
    return U(this, void 0, void 0, function*() {
        return NT(t, "POST", e, n, s, r)
    })
}
class IT {
    constructor(e, r={}, n) {
        this.shouldThrowOnError = !1,
        this.url = e.replace(/\/$/, ""),
        this.headers = Object.assign(Object.assign({}, Jd), r),
        this.fetch = Yd(n)
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    createIndex(e) {
        return U(this, void 0, void 0, function*() {
            try {
                return {
                    data: (yield st(this.fetch, `${this.url}/CreateIndex`, e, {
                        headers: this.headers
                    })) || {},
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (nt(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    getIndex(e, r) {
        return U(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield st(this.fetch, `${this.url}/GetIndex`, {
                        vectorBucketName: e,
                        indexName: r
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (n) {
                if (this.shouldThrowOnError)
                    throw n;
                if (nt(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        })
    }
    listIndexes(e) {
        return U(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield st(this.fetch, `${this.url}/ListIndexes`, e, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (nt(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    deleteIndex(e, r) {
        return U(this, void 0, void 0, function*() {
            try {
                return {
                    data: (yield st(this.fetch, `${this.url}/DeleteIndex`, {
                        vectorBucketName: e,
                        indexName: r
                    }, {
                        headers: this.headers
                    })) || {},
                    error: null
                }
            } catch (n) {
                if (this.shouldThrowOnError)
                    throw n;
                if (nt(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        })
    }
}
class $T {
    constructor(e, r={}, n) {
        this.shouldThrowOnError = !1,
        this.url = e.replace(/\/$/, ""),
        this.headers = Object.assign(Object.assign({}, Jd), r),
        this.fetch = Yd(n)
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    putVectors(e) {
        return U(this, void 0, void 0, function*() {
            try {
                if (e.vectors.length < 1 || e.vectors.length > 500)
                    throw new Error("Vector batch size must be between 1 and 500 items");
                return {
                    data: (yield st(this.fetch, `${this.url}/PutVectors`, e, {
                        headers: this.headers
                    })) || {},
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (nt(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    getVectors(e) {
        return U(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield st(this.fetch, `${this.url}/GetVectors`, e, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (nt(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    listVectors(e) {
        return U(this, void 0, void 0, function*() {
            try {
                if (e.segmentCount !== void 0) {
                    if (e.segmentCount < 1 || e.segmentCount > 16)
                        throw new Error("segmentCount must be between 1 and 16");
                    if (e.segmentIndex !== void 0 && (e.segmentIndex < 0 || e.segmentIndex >= e.segmentCount))
                        throw new Error(`segmentIndex must be between 0 and ${e.segmentCount - 1}`)
                }
                return {
                    data: yield st(this.fetch, `${this.url}/ListVectors`, e, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (nt(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    queryVectors(e) {
        return U(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield st(this.fetch, `${this.url}/QueryVectors`, e, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (nt(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    deleteVectors(e) {
        return U(this, void 0, void 0, function*() {
            try {
                if (e.keys.length < 1 || e.keys.length > 500)
                    throw new Error("Keys batch size must be between 1 and 500 items");
                return {
                    data: (yield st(this.fetch, `${this.url}/DeleteVectors`, e, {
                        headers: this.headers
                    })) || {},
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (nt(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
}
class LT {
    constructor(e, r={}, n) {
        this.shouldThrowOnError = !1,
        this.url = e.replace(/\/$/, ""),
        this.headers = Object.assign(Object.assign({}, Jd), r),
        this.fetch = Yd(n)
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    createBucket(e) {
        return U(this, void 0, void 0, function*() {
            try {
                return {
                    data: (yield st(this.fetch, `${this.url}/CreateVectorBucket`, {
                        vectorBucketName: e
                    }, {
                        headers: this.headers
                    })) || {},
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (nt(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    getBucket(e) {
        return U(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield st(this.fetch, `${this.url}/GetVectorBucket`, {
                        vectorBucketName: e
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (nt(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    listBuckets() {
        return U(this, arguments, void 0, function*(e={}) {
            try {
                return {
                    data: yield st(this.fetch, `${this.url}/ListVectorBuckets`, e, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (nt(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    deleteBucket(e) {
        return U(this, void 0, void 0, function*() {
            try {
                return {
                    data: (yield st(this.fetch, `${this.url}/DeleteVectorBucket`, {
                        vectorBucketName: e
                    }, {
                        headers: this.headers
                    })) || {},
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (nt(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
}
class UT extends LT {
    constructor(e, r={}) {
        super(e, r.headers || {}, r.fetch)
    }
    from(e) {
        return new DT(this.url,this.headers,e,this.fetch)
    }
    createBucket(e) {
        const r = Object.create(null, {
            createBucket: {
                get: ()=>super.createBucket
            }
        });
        return U(this, void 0, void 0, function*() {
            return r.createBucket.call(this, e)
        })
    }
    getBucket(e) {
        const r = Object.create(null, {
            getBucket: {
                get: ()=>super.getBucket
            }
        });
        return U(this, void 0, void 0, function*() {
            return r.getBucket.call(this, e)
        })
    }
    listBuckets() {
        const e = Object.create(null, {
            listBuckets: {
                get: ()=>super.listBuckets
            }
        });
        return U(this, arguments, void 0, function*(r={}) {
            return e.listBuckets.call(this, r)
        })
    }
    deleteBucket(e) {
        const r = Object.create(null, {
            deleteBucket: {
                get: ()=>super.deleteBucket
            }
        });
        return U(this, void 0, void 0, function*() {
            return r.deleteBucket.call(this, e)
        })
    }
}
class DT extends IT {
    constructor(e, r, n, s) {
        super(e, r, s),
        this.vectorBucketName = n
    }
    createIndex(e) {
        const r = Object.create(null, {
            createIndex: {
                get: ()=>super.createIndex
            }
        });
        return U(this, void 0, void 0, function*() {
            return r.createIndex.call(this, Object.assign(Object.assign({}, e), {
                vectorBucketName: this.vectorBucketName
            }))
        })
    }
    listIndexes() {
        const e = Object.create(null, {
            listIndexes: {
                get: ()=>super.listIndexes
            }
        });
        return U(this, arguments, void 0, function*(r={}) {
            return e.listIndexes.call(this, Object.assign(Object.assign({}, r), {
                vectorBucketName: this.vectorBucketName
            }))
        })
    }
    getIndex(e) {
        const r = Object.create(null, {
            getIndex: {
                get: ()=>super.getIndex
            }
        });
        return U(this, void 0, void 0, function*() {
            return r.getIndex.call(this, this.vectorBucketName, e)
        })
    }
    deleteIndex(e) {
        const r = Object.create(null, {
            deleteIndex: {
                get: ()=>super.deleteIndex
            }
        });
        return U(this, void 0, void 0, function*() {
            return r.deleteIndex.call(this, this.vectorBucketName, e)
        })
    }
    index(e) {
        return new MT(this.url,this.headers,this.vectorBucketName,e,this.fetch)
    }
}
class MT extends $T {
    constructor(e, r, n, s, i) {
        super(e, r, i),
        this.vectorBucketName = n,
        this.indexName = s
    }
    putVectors(e) {
        const r = Object.create(null, {
            putVectors: {
                get: ()=>super.putVectors
            }
        });
        return U(this, void 0, void 0, function*() {
            return r.putVectors.call(this, Object.assign(Object.assign({}, e), {
                vectorBucketName: this.vectorBucketName,
                indexName: this.indexName
            }))
        })
    }
    getVectors(e) {
        const r = Object.create(null, {
            getVectors: {
                get: ()=>super.getVectors
            }
        });
        return U(this, void 0, void 0, function*() {
            return r.getVectors.call(this, Object.assign(Object.assign({}, e), {
                vectorBucketName: this.vectorBucketName,
                indexName: this.indexName
            }))
        })
    }
    listVectors() {
        const e = Object.create(null, {
            listVectors: {
                get: ()=>super.listVectors
            }
        });
        return U(this, arguments, void 0, function*(r={}) {
            return e.listVectors.call(this, Object.assign(Object.assign({}, r), {
                vectorBucketName: this.vectorBucketName,
                indexName: this.indexName
            }))
        })
    }
    queryVectors(e) {
        const r = Object.create(null, {
            queryVectors: {
                get: ()=>super.queryVectors
            }
        });
        return U(this, void 0, void 0, function*() {
            return r.queryVectors.call(this, Object.assign(Object.assign({}, e), {
                vectorBucketName: this.vectorBucketName,
                indexName: this.indexName
            }))
        })
    }
    deleteVectors(e) {
        const r = Object.create(null, {
            deleteVectors: {
                get: ()=>super.deleteVectors
            }
        });
        return U(this, void 0, void 0, function*() {
            return r.deleteVectors.call(this, Object.assign(Object.assign({}, e), {
                vectorBucketName: this.vectorBucketName,
                indexName: this.indexName
            }))
        })
    }
}
class FT extends _T {
    constructor(e, r={}, n, s) {
        super(e, r, n, s)
    }
    from(e) {
        return new bT(this.url,this.headers,e,this.fetch)
    }
    get vectors() {
        return new UT(this.url + "/vector",{
            headers: this.headers,
            fetch: this.fetch
        })
    }
    get analytics() {
        return new PT(this.url + "/iceberg",this.headers,this.fetch)
    }
}
const BT = "2.86.0";
let li = "";
typeof Deno < "u" ? li = "deno" : typeof document < "u" ? li = "web" : typeof navigator < "u" && navigator.product === "ReactNative" ? li = "react-native" : li = "node";
const zT = {
    "X-Client-Info": `supabase-js-${li}/${BT}`
}
  , VT = {
    headers: zT
}
  , WT = {
    schema: "public"
}
  , HT = {
    autoRefreshToken: !0,
    persistSession: !0,
    detectSessionInUrl: !0,
    flowType: "implicit"
}
  , qT = {}
  , KT = t=>t ? (...e)=>t(...e) : (...e)=>fetch(...e)
  , GT = ()=>Headers
  , QT = (t,e,r)=>{
    const n = KT(r)
      , s = GT();
    return async(i,o)=>{
        var a;
        const l = (a = await e()) !== null && a !== void 0 ? a : t;
        let u = new s(o == null ? void 0 : o.headers);
        return u.has("apikey") || u.set("apikey", t),
        u.has("Authorization") || u.set("Authorization", `Bearer ${l}`),
        n(i, Object.assign(Object.assign({}, o), {
            headers: u
        }))
    }
}
;
function JT(t) {
    return t.endsWith("/") ? t : t + "/"
}
function YT(t, e) {
    var r, n;
    const {db: s, auth: i, realtime: o, global: a} = t
      , {db: l, auth: u, realtime: c, global: h} = e
      , f = {
        db: Object.assign(Object.assign({}, l), s),
        auth: Object.assign(Object.assign({}, u), i),
        realtime: Object.assign(Object.assign({}, c), o),
        storage: {},
        global: Object.assign(Object.assign(Object.assign({}, h), a), {
            headers: Object.assign(Object.assign({}, (r = h == null ? void 0 : h.headers) !== null && r !== void 0 ? r : {}), (n = a == null ? void 0 : a.headers) !== null && n !== void 0 ? n : {})
        }),
        accessToken: async()=>""
    };
    return t.accessToken ? f.accessToken = t.accessToken : delete f.accessToken,
    f
}
function XT(t) {
    const e = t == null ? void 0 : t.trim();
    if (!e)
        throw new Error("supabaseUrl is required.");
    if (!e.match(/^https?:\/\//i))
        throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");
    try {
        return new URL(JT(e))
    } catch {
        throw Error("Invalid supabaseUrl: Provided URL is malformed.")
    }
}
const Ty = "2.86.0"
  , Gn = 30 * 1e3
  , Cc = 3
  , iu = Cc * Gn
  , ZT = "http://localhost:9999"
  , eC = "supabase.auth.token"
  , tC = {
    "X-Client-Info": `gotrue-js/${Ty}`
}
  , Pc = "X-Supabase-Api-Version"
  , Cy = {
    "2024-01-01": {
        timestamp: Date.parse("2024-01-01T00:00:00.0Z"),
        name: "2024-01-01"
    }
}
  , rC = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i
  , nC = 10 * 60 * 1e3;
class Wi extends Error {
    constructor(e, r, n) {
        super(e),
        this.__isAuthError = !0,
        this.name = "AuthError",
        this.status = r,
        this.code = n
    }
}
function M(t) {
    return typeof t == "object" && t !== null && "__isAuthError"in t
}
class sC extends Wi {
    constructor(e, r, n) {
        super(e, r, n),
        this.name = "AuthApiError",
        this.status = r,
        this.code = n
    }
}
function iC(t) {
    return M(t) && t.name === "AuthApiError"
}
class pn extends Wi {
    constructor(e, r) {
        super(e),
        this.name = "AuthUnknownError",
        this.originalError = r
    }
}
class rn extends Wi {
    constructor(e, r, n, s) {
        super(e, n, s),
        this.name = r,
        this.status = n
    }
}
class et extends rn {
    constructor() {
        super("Auth session missing!", "AuthSessionMissingError", 400, void 0)
    }
}
function oC(t) {
    return M(t) && t.name === "AuthSessionMissingError"
}
class Vn extends rn {
    constructor() {
        super("Auth session or user missing", "AuthInvalidTokenResponseError", 500, void 0)
    }
}
class Do extends rn {
    constructor(e) {
        super(e, "AuthInvalidCredentialsError", 400, void 0)
    }
}
class Mo extends rn {
    constructor(e, r=null) {
        super(e, "AuthImplicitGrantRedirectError", 500, void 0),
        this.details = null,
        this.details = r
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            status: this.status,
            details: this.details
        }
    }
}
function aC(t) {
    return M(t) && t.name === "AuthImplicitGrantRedirectError"
}
class pp extends rn {
    constructor(e, r=null) {
        super(e, "AuthPKCEGrantCodeExchangeError", 500, void 0),
        this.details = null,
        this.details = r
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            status: this.status,
            details: this.details
        }
    }
}
class Oc extends rn {
    constructor(e, r) {
        super(e, "AuthRetryableFetchError", r, void 0)
    }
}
function ou(t) {
    return M(t) && t.name === "AuthRetryableFetchError"
}
class mp extends rn {
    constructor(e, r, n) {
        super(e, "AuthWeakPasswordError", r, "weak_password"),
        this.reasons = n
    }
}
class Rc extends rn {
    constructor(e) {
        super(e, "AuthInvalidJwtError", 400, "invalid_jwt")
    }
}
const La = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split("")
  , gp = ` 	
\r=`.split("")
  , lC = (()=>{
    const t = new Array(128);
    for (let e = 0; e < t.length; e += 1)
        t[e] = -1;
    for (let e = 0; e < gp.length; e += 1)
        t[gp[e].charCodeAt(0)] = -2;
    for (let e = 0; e < La.length; e += 1)
        t[La[e].charCodeAt(0)] = e;
    return t
}
)();
function vp(t, e, r) {
    if (t !== null)
        for (e.queue = e.queue << 8 | t,
        e.queuedBits += 8; e.queuedBits >= 6; ) {
            const n = e.queue >> e.queuedBits - 6 & 63;
            r(La[n]),
            e.queuedBits -= 6
        }
    else if (e.queuedBits > 0)
        for (e.queue = e.queue << 6 - e.queuedBits,
        e.queuedBits = 6; e.queuedBits >= 6; ) {
            const n = e.queue >> e.queuedBits - 6 & 63;
            r(La[n]),
            e.queuedBits -= 6
        }
}
function Py(t, e, r) {
    const n = lC[t];
    if (n > -1)
        for (e.queue = e.queue << 6 | n,
        e.queuedBits += 6; e.queuedBits >= 8; )
            r(e.queue >> e.queuedBits - 8 & 255),
            e.queuedBits -= 8;
    else {
        if (n === -2)
            return;
        throw new Error(`Invalid Base64-URL character "${String.fromCharCode(t)}"`)
    }
}
function yp(t) {
    const e = []
      , r = o=>{
        e.push(String.fromCodePoint(o))
    }
      , n = {
        utf8seq: 0,
        codepoint: 0
    }
      , s = {
        queue: 0,
        queuedBits: 0
    }
      , i = o=>{
        dC(o, n, r)
    }
    ;
    for (let o = 0; o < t.length; o += 1)
        Py(t.charCodeAt(o), s, i);
    return e.join("")
}
function uC(t, e) {
    if (t <= 127) {
        e(t);
        return
    } else if (t <= 2047) {
        e(192 | t >> 6),
        e(128 | t & 63);
        return
    } else if (t <= 65535) {
        e(224 | t >> 12),
        e(128 | t >> 6 & 63),
        e(128 | t & 63);
        return
    } else if (t <= 1114111) {
        e(240 | t >> 18),
        e(128 | t >> 12 & 63),
        e(128 | t >> 6 & 63),
        e(128 | t & 63);
        return
    }
    throw new Error(`Unrecognized Unicode codepoint: ${t.toString(16)}`)
}
function cC(t, e) {
    for (let r = 0; r < t.length; r += 1) {
        let n = t.charCodeAt(r);
        if (n > 55295 && n <= 56319) {
            const s = (n - 55296) * 1024 & 65535;
            n = (t.charCodeAt(r + 1) - 56320 & 65535 | s) + 65536,
            r += 1
        }
        uC(n, e)
    }
}
function dC(t, e, r) {
    if (e.utf8seq === 0) {
        if (t <= 127) {
            r(t);
            return
        }
        for (let n = 1; n < 6; n += 1)
            if (!(t >> 7 - n & 1)) {
                e.utf8seq = n;
                break
            }
        if (e.utf8seq === 2)
            e.codepoint = t & 31;
        else if (e.utf8seq === 3)
            e.codepoint = t & 15;
        else if (e.utf8seq === 4)
            e.codepoint = t & 7;
        else
            throw new Error("Invalid UTF-8 sequence");
        e.utf8seq -= 1
    } else if (e.utf8seq > 0) {
        if (t <= 127)
            throw new Error("Invalid UTF-8 sequence");
        e.codepoint = e.codepoint << 6 | t & 63,
        e.utf8seq -= 1,
        e.utf8seq === 0 && r(e.codepoint)
    }
}
function ys(t) {
    const e = []
      , r = {
        queue: 0,
        queuedBits: 0
    }
      , n = s=>{
        e.push(s)
    }
    ;
    for (let s = 0; s < t.length; s += 1)
        Py(t.charCodeAt(s), r, n);
    return new Uint8Array(e)
}
function hC(t) {
    const e = [];
    return cC(t, r=>e.push(r)),
    new Uint8Array(e)
}
function yn(t) {
    const e = []
      , r = {
        queue: 0,
        queuedBits: 0
    }
      , n = s=>{
        e.push(s)
    }
    ;
    return t.forEach(s=>vp(s, r, n)),
    vp(null, r, n),
    e.join("")
}
function fC(t) {
    return Math.round(Date.now() / 1e3) + t
}
function pC() {
    return Symbol("auth-callback")
}
const Pe = ()=>typeof window < "u" && typeof document < "u"
  , an = {
    tested: !1,
    writable: !1
}
  , Oy = ()=>{
    if (!Pe())
        return !1;
    try {
        if (typeof globalThis.localStorage != "object")
            return !1
    } catch {
        return !1
    }
    if (an.tested)
        return an.writable;
    const t = `lswt-${Math.random()}${Math.random()}`;
    try {
        globalThis.localStorage.setItem(t, t),
        globalThis.localStorage.removeItem(t),
        an.tested = !0,
        an.writable = !0
    } catch {
        an.tested = !0,
        an.writable = !1
    }
    return an.writable
}
;
function mC(t) {
    const e = {}
      , r = new URL(t);
    if (r.hash && r.hash[0] === "#")
        try {
            new URLSearchParams(r.hash.substring(1)).forEach((s,i)=>{
                e[i] = s
            }
            )
        } catch {}
    return r.searchParams.forEach((n,s)=>{
        e[s] = n
    }
    ),
    e
}
const Ry = t=>t ? (...e)=>t(...e) : (...e)=>fetch(...e)
  , gC = t=>typeof t == "object" && t !== null && "status"in t && "ok"in t && "json"in t && typeof t.json == "function"
  , Qn = async(t,e,r)=>{
    await t.setItem(e, JSON.stringify(r))
}
  , ln = async(t,e)=>{
    const r = await t.getItem(e);
    if (!r)
        return null;
    try {
        return JSON.parse(r)
    } catch {
        return r
    }
}
  , Er = async(t,e)=>{
    await t.removeItem(e)
}
;
class gl {
    constructor() {
        this.promise = new gl.promiseConstructor((e,r)=>{
            this.resolve = e,
            this.reject = r
        }
        )
    }
}
gl.promiseConstructor = Promise;
function au(t) {
    const e = t.split(".");
    if (e.length !== 3)
        throw new Rc("Invalid JWT structure");
    for (let n = 0; n < e.length; n++)
        if (!rC.test(e[n]))
            throw new Rc("JWT not in base64url format");
    return {
        header: JSON.parse(yp(e[0])),
        payload: JSON.parse(yp(e[1])),
        signature: ys(e[2]),
        raw: {
            header: e[0],
            payload: e[1]
        }
    }
}
async function vC(t) {
    return await new Promise(e=>{
        setTimeout(()=>e(null), t)
    }
    )
}
function yC(t, e) {
    return new Promise((n,s)=>{
        (async()=>{
            for (let i = 0; i < 1 / 0; i++)
                try {
                    const o = await t(i);
                    if (!e(i, null, o)) {
                        n(o);
                        return
                    }
                } catch (o) {
                    if (!e(i, o)) {
                        s(o);
                        return
                    }
                }
        }
        )()
    }
    )
}
function wC(t) {
    return ("0" + t.toString(16)).substr(-2)
}
function bC() {
    const e = new Uint32Array(56);
    if (typeof crypto > "u") {
        const r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~"
          , n = r.length;
        let s = "";
        for (let i = 0; i < 56; i++)
            s += r.charAt(Math.floor(Math.random() * n));
        return s
    }
    return crypto.getRandomValues(e),
    Array.from(e, wC).join("")
}
async function _C(t) {
    const r = new TextEncoder().encode(t)
      , n = await crypto.subtle.digest("SHA-256", r)
      , s = new Uint8Array(n);
    return Array.from(s).map(i=>String.fromCharCode(i)).join("")
}
async function xC(t) {
    if (!(typeof crypto < "u" && typeof crypto.subtle < "u" && typeof TextEncoder < "u"))
        return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."),
        t;
    const r = await _C(t);
    return btoa(r).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "")
}
async function Wn(t, e, r=!1) {
    const n = bC();
    let s = n;
    r && (s += "/PASSWORD_RECOVERY"),
    await Qn(t, `${e}-code-verifier`, s);
    const i = await xC(n);
    return [i, n === i ? "plain" : "s256"]
}
const EC = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
function SC(t) {
    const e = t.headers.get(Pc);
    if (!e || !e.match(EC))
        return null;
    try {
        return new Date(`${e}T00:00:00.0Z`)
    } catch {
        return null
    }
}
function kC(t) {
    if (!t)
        throw new Error("Missing exp claim");
    const e = Math.floor(Date.now() / 1e3);
    if (t <= e)
        throw new Error("JWT has expired")
}
function TC(t) {
    switch (t) {
    case "RS256":
        return {
            name: "RSASSA-PKCS1-v1_5",
            hash: {
                name: "SHA-256"
            }
        };
    case "ES256":
        return {
            name: "ECDSA",
            namedCurve: "P-256",
            hash: {
                name: "SHA-256"
            }
        };
    default:
        throw new Error("Invalid alg claim")
    }
}
const CC = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
function Hn(t) {
    if (!CC.test(t))
        throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not")
}
function lu() {
    const t = {};
    return new Proxy(t,{
        get: (e,r)=>{
            if (r === "__isUserNotAvailableProxy")
                return !0;
            if (typeof r == "symbol") {
                const n = r.toString();
                if (n === "Symbol(Symbol.toPrimitive)" || n === "Symbol(Symbol.toStringTag)" || n === "Symbol(util.inspect.custom)")
                    return
            }
            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${r}" property of the session object is not supported. Please use getUser() instead.`)
        }
        ,
        set: (e,r)=>{
            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${r}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)
        }
        ,
        deleteProperty: (e,r)=>{
            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${r}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)
        }
    })
}
function PC(t, e) {
    return new Proxy(t,{
        get: (r,n,s)=>{
            if (n === "__isInsecureUserWarningProxy")
                return !0;
            if (typeof n == "symbol") {
                const i = n.toString();
                if (i === "Symbol(Symbol.toPrimitive)" || i === "Symbol(Symbol.toStringTag)" || i === "Symbol(util.inspect.custom)" || i === "Symbol(nodejs.util.inspect.custom)")
                    return Reflect.get(r, n, s)
            }
            return !e.value && typeof n == "string" && (console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."),
            e.value = !0),
            Reflect.get(r, n, s)
        }
    })
}
function wp(t) {
    return JSON.parse(JSON.stringify(t))
}
const dn = t=>t.msg || t.message || t.error_description || t.error || JSON.stringify(t)
  , OC = [502, 503, 504];
async function bp(t) {
    var e;
    if (!gC(t))
        throw new Oc(dn(t),0);
    if (OC.includes(t.status))
        throw new Oc(dn(t),t.status);
    let r;
    try {
        r = await t.json()
    } catch (i) {
        throw new pn(dn(i),i)
    }
    let n;
    const s = SC(t);
    if (s && s.getTime() >= Cy["2024-01-01"].timestamp && typeof r == "object" && r && typeof r.code == "string" ? n = r.code : typeof r == "object" && r && typeof r.error_code == "string" && (n = r.error_code),
    n) {
        if (n === "weak_password")
            throw new mp(dn(r),t.status,((e = r.weak_password) === null || e === void 0 ? void 0 : e.reasons) || []);
        if (n === "session_not_found")
            throw new et
    } else if (typeof r == "object" && r && typeof r.weak_password == "object" && r.weak_password && Array.isArray(r.weak_password.reasons) && r.weak_password.reasons.length && r.weak_password.reasons.reduce((i,o)=>i && typeof o == "string", !0))
        throw new mp(dn(r),t.status,r.weak_password.reasons);
    throw new sC(dn(r),t.status || 500,n)
}
const RC = (t,e,r,n)=>{
    const s = {
        method: t,
        headers: (e == null ? void 0 : e.headers) || {}
    };
    return t === "GET" ? s : (s.headers = Object.assign({
        "Content-Type": "application/json;charset=UTF-8"
    }, e == null ? void 0 : e.headers),
    s.body = JSON.stringify(n),
    Object.assign(Object.assign({}, s), r))
}
;
async function B(t, e, r, n) {
    var s;
    const i = Object.assign({}, n == null ? void 0 : n.headers);
    i[Pc] || (i[Pc] = Cy["2024-01-01"].name),
    n != null && n.jwt && (i.Authorization = `Bearer ${n.jwt}`);
    const o = (s = n == null ? void 0 : n.query) !== null && s !== void 0 ? s : {};
    n != null && n.redirectTo && (o.redirect_to = n.redirectTo);
    const a = Object.keys(o).length ? "?" + new URLSearchParams(o).toString() : ""
      , l = await jC(t, e, r + a, {
        headers: i,
        noResolveJson: n == null ? void 0 : n.noResolveJson
    }, {}, n == null ? void 0 : n.body);
    return n != null && n.xform ? n == null ? void 0 : n.xform(l) : {
        data: Object.assign({}, l),
        error: null
    }
}
async function jC(t, e, r, n, s, i) {
    const o = RC(e, n, s, i);
    let a;
    try {
        a = await t(r, Object.assign({}, o))
    } catch (l) {
        throw console.error(l),
        new Oc(dn(l),0)
    }
    if (a.ok || await bp(a),
    n != null && n.noResolveJson)
        return a;
    try {
        return await a.json()
    } catch (l) {
        await bp(l)
    }
}
function St(t) {
    var e;
    let r = null;
    IC(t) && (r = Object.assign({}, t),
    t.expires_at || (r.expires_at = fC(t.expires_in)));
    const n = (e = t.user) !== null && e !== void 0 ? e : t;
    return {
        data: {
            session: r,
            user: n
        },
        error: null
    }
}
function _p(t) {
    const e = St(t);
    return !e.error && t.weak_password && typeof t.weak_password == "object" && Array.isArray(t.weak_password.reasons) && t.weak_password.reasons.length && t.weak_password.message && typeof t.weak_password.message == "string" && t.weak_password.reasons.reduce((r,n)=>r && typeof n == "string", !0) && (e.data.weak_password = t.weak_password),
    e
}
function Rr(t) {
    var e;
    return {
        data: {
            user: (e = t.user) !== null && e !== void 0 ? e : t
        },
        error: null
    }
}
function AC(t) {
    return {
        data: t,
        error: null
    }
}
function NC(t) {
    const {action_link: e, email_otp: r, hashed_token: n, redirect_to: s, verification_type: i} = t
      , o = Vs(t, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"])
      , a = {
        action_link: e,
        email_otp: r,
        hashed_token: n,
        redirect_to: s,
        verification_type: i
    }
      , l = Object.assign({}, o);
    return {
        data: {
            properties: a,
            user: l
        },
        error: null
    }
}
function xp(t) {
    return t
}
function IC(t) {
    return t.access_token && t.refresh_token && t.expires_in
}
const uu = ["global", "local", "others"];
class $C {
    constructor({url: e="", headers: r={}, fetch: n}) {
        this.url = e,
        this.headers = r,
        this.fetch = Ry(n),
        this.mfa = {
            listFactors: this._listFactors.bind(this),
            deleteFactor: this._deleteFactor.bind(this)
        },
        this.oauth = {
            listClients: this._listOAuthClients.bind(this),
            createClient: this._createOAuthClient.bind(this),
            getClient: this._getOAuthClient.bind(this),
            updateClient: this._updateOAuthClient.bind(this),
            deleteClient: this._deleteOAuthClient.bind(this),
            regenerateClientSecret: this._regenerateOAuthClientSecret.bind(this)
        }
    }
    async signOut(e, r=uu[0]) {
        if (uu.indexOf(r) < 0)
            throw new Error(`@supabase/auth-js: Parameter scope must be one of ${uu.join(", ")}`);
        try {
            return await B(this.fetch, "POST", `${this.url}/logout?scope=${r}`, {
                headers: this.headers,
                jwt: e,
                noResolveJson: !0
            }),
            {
                data: null,
                error: null
            }
        } catch (n) {
            if (M(n))
                return {
                    data: null,
                    error: n
                };
            throw n
        }
    }
    async inviteUserByEmail(e, r={}) {
        try {
            return await B(this.fetch, "POST", `${this.url}/invite`, {
                body: {
                    email: e,
                    data: r.data
                },
                headers: this.headers,
                redirectTo: r.redirectTo,
                xform: Rr
            })
        } catch (n) {
            if (M(n))
                return {
                    data: {
                        user: null
                    },
                    error: n
                };
            throw n
        }
    }
    async generateLink(e) {
        try {
            const {options: r} = e
              , n = Vs(e, ["options"])
              , s = Object.assign(Object.assign({}, n), r);
            return "newEmail"in n && (s.new_email = n == null ? void 0 : n.newEmail,
            delete s.newEmail),
            await B(this.fetch, "POST", `${this.url}/admin/generate_link`, {
                body: s,
                headers: this.headers,
                xform: NC,
                redirectTo: r == null ? void 0 : r.redirectTo
            })
        } catch (r) {
            if (M(r))
                return {
                    data: {
                        properties: null,
                        user: null
                    },
                    error: r
                };
            throw r
        }
    }
    async createUser(e) {
        try {
            return await B(this.fetch, "POST", `${this.url}/admin/users`, {
                body: e,
                headers: this.headers,
                xform: Rr
            })
        } catch (r) {
            if (M(r))
                return {
                    data: {
                        user: null
                    },
                    error: r
                };
            throw r
        }
    }
    async listUsers(e) {
        var r, n, s, i, o, a, l;
        try {
            const u = {
                nextPage: null,
                lastPage: 0,
                total: 0
            }
              , c = await B(this.fetch, "GET", `${this.url}/admin/users`, {
                headers: this.headers,
                noResolveJson: !0,
                query: {
                    page: (n = (r = e == null ? void 0 : e.page) === null || r === void 0 ? void 0 : r.toString()) !== null && n !== void 0 ? n : "",
                    per_page: (i = (s = e == null ? void 0 : e.perPage) === null || s === void 0 ? void 0 : s.toString()) !== null && i !== void 0 ? i : ""
                },
                xform: xp
            });
            if (c.error)
                throw c.error;
            const h = await c.json()
              , f = (o = c.headers.get("x-total-count")) !== null && o !== void 0 ? o : 0
              , d = (l = (a = c.headers.get("link")) === null || a === void 0 ? void 0 : a.split(",")) !== null && l !== void 0 ? l : [];
            return d.length > 0 && (d.forEach(y=>{
                const m = parseInt(y.split(";")[0].split("=")[1].substring(0, 1))
                  , w = JSON.parse(y.split(";")[1].split("=")[1]);
                u[`${w}Page`] = m
            }
            ),
            u.total = parseInt(f)),
            {
                data: Object.assign(Object.assign({}, h), u),
                error: null
            }
        } catch (u) {
            if (M(u))
                return {
                    data: {
                        users: []
                    },
                    error: u
                };
            throw u
        }
    }
    async getUserById(e) {
        Hn(e);
        try {
            return await B(this.fetch, "GET", `${this.url}/admin/users/${e}`, {
                headers: this.headers,
                xform: Rr
            })
        } catch (r) {
            if (M(r))
                return {
                    data: {
                        user: null
                    },
                    error: r
                };
            throw r
        }
    }
    async updateUserById(e, r) {
        Hn(e);
        try {
            return await B(this.fetch, "PUT", `${this.url}/admin/users/${e}`, {
                body: r,
                headers: this.headers,
                xform: Rr
            })
        } catch (n) {
            if (M(n))
                return {
                    data: {
                        user: null
                    },
                    error: n
                };
            throw n
        }
    }
    async deleteUser(e, r=!1) {
        Hn(e);
        try {
            return await B(this.fetch, "DELETE", `${this.url}/admin/users/${e}`, {
                headers: this.headers,
                body: {
                    should_soft_delete: r
                },
                xform: Rr
            })
        } catch (n) {
            if (M(n))
                return {
                    data: {
                        user: null
                    },
                    error: n
                };
            throw n
        }
    }
    async _listFactors(e) {
        Hn(e.userId);
        try {
            const {data: r, error: n} = await B(this.fetch, "GET", `${this.url}/admin/users/${e.userId}/factors`, {
                headers: this.headers,
                xform: s=>({
                    data: {
                        factors: s
                    },
                    error: null
                })
            });
            return {
                data: r,
                error: n
            }
        } catch (r) {
            if (M(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async _deleteFactor(e) {
        Hn(e.userId),
        Hn(e.id);
        try {
            return {
                data: await B(this.fetch, "DELETE", `${this.url}/admin/users/${e.userId}/factors/${e.id}`, {
                    headers: this.headers
                }),
                error: null
            }
        } catch (r) {
            if (M(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async _listOAuthClients(e) {
        var r, n, s, i, o, a, l;
        try {
            const u = {
                nextPage: null,
                lastPage: 0,
                total: 0
            }
              , c = await B(this.fetch, "GET", `${this.url}/admin/oauth/clients`, {
                headers: this.headers,
                noResolveJson: !0,
                query: {
                    page: (n = (r = e == null ? void 0 : e.page) === null || r === void 0 ? void 0 : r.toString()) !== null && n !== void 0 ? n : "",
                    per_page: (i = (s = e == null ? void 0 : e.perPage) === null || s === void 0 ? void 0 : s.toString()) !== null && i !== void 0 ? i : ""
                },
                xform: xp
            });
            if (c.error)
                throw c.error;
            const h = await c.json()
              , f = (o = c.headers.get("x-total-count")) !== null && o !== void 0 ? o : 0
              , d = (l = (a = c.headers.get("link")) === null || a === void 0 ? void 0 : a.split(",")) !== null && l !== void 0 ? l : [];
            return d.length > 0 && (d.forEach(y=>{
                const m = parseInt(y.split(";")[0].split("=")[1].substring(0, 1))
                  , w = JSON.parse(y.split(";")[1].split("=")[1]);
                u[`${w}Page`] = m
            }
            ),
            u.total = parseInt(f)),
            {
                data: Object.assign(Object.assign({}, h), u),
                error: null
            }
        } catch (u) {
            if (M(u))
                return {
                    data: {
                        clients: []
                    },
                    error: u
                };
            throw u
        }
    }
    async _createOAuthClient(e) {
        try {
            return await B(this.fetch, "POST", `${this.url}/admin/oauth/clients`, {
                body: e,
                headers: this.headers,
                xform: r=>({
                    data: r,
                    error: null
                })
            })
        } catch (r) {
            if (M(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async _getOAuthClient(e) {
        try {
            return await B(this.fetch, "GET", `${this.url}/admin/oauth/clients/${e}`, {
                headers: this.headers,
                xform: r=>({
                    data: r,
                    error: null
                })
            })
        } catch (r) {
            if (M(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async _updateOAuthClient(e, r) {
        try {
            return await B(this.fetch, "PUT", `${this.url}/admin/oauth/clients/${e}`, {
                body: r,
                headers: this.headers,
                xform: n=>({
                    data: n,
                    error: null
                })
            })
        } catch (n) {
            if (M(n))
                return {
                    data: null,
                    error: n
                };
            throw n
        }
    }
    async _deleteOAuthClient(e) {
        try {
            return await B(this.fetch, "DELETE", `${this.url}/admin/oauth/clients/${e}`, {
                headers: this.headers,
                noResolveJson: !0
            }),
            {
                data: null,
                error: null
            }
        } catch (r) {
            if (M(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async _regenerateOAuthClientSecret(e) {
        try {
            return await B(this.fetch, "POST", `${this.url}/admin/oauth/clients/${e}/regenerate_secret`, {
                headers: this.headers,
                xform: r=>({
                    data: r,
                    error: null
                })
            })
        } catch (r) {
            if (M(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
}
function Ep(t={}) {
    return {
        getItem: e=>t[e] || null,
        setItem: (e,r)=>{
            t[e] = r
        }
        ,
        removeItem: e=>{
            delete t[e]
        }
    }
}
const qn = {
    debug: !!(globalThis && Oy() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true")
};
class jy extends Error {
    constructor(e) {
        super(e),
        this.isAcquireTimeout = !0
    }
}
class LC extends jy {
}
async function UC(t, e, r) {
    qn.debug && console.log("@supabase/gotrue-js: navigatorLock: acquire lock", t, e);
    const n = new globalThis.AbortController;
    return e > 0 && setTimeout(()=>{
        n.abort(),
        qn.debug && console.log("@supabase/gotrue-js: navigatorLock acquire timed out", t)
    }
    , e),
    await Promise.resolve().then(()=>globalThis.navigator.locks.request(t, e === 0 ? {
        mode: "exclusive",
        ifAvailable: !0
    } : {
        mode: "exclusive",
        signal: n.signal
    }, async s=>{
        if (s) {
            qn.debug && console.log("@supabase/gotrue-js: navigatorLock: acquired", t, s.name);
            try {
                return await r()
            } finally {
                qn.debug && console.log("@supabase/gotrue-js: navigatorLock: released", t, s.name)
            }
        } else {
            if (e === 0)
                throw qn.debug && console.log("@supabase/gotrue-js: navigatorLock: not immediately available", t),
                new LC(`Acquiring an exclusive Navigator LockManager lock "${t}" immediately failed`);
            if (qn.debug)
                try {
                    const i = await globalThis.navigator.locks.query();
                    console.log("@supabase/gotrue-js: Navigator LockManager state", JSON.stringify(i, null, "  "))
                } catch (i) {
                    console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state", i)
                }
            return console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"),
            await r()
        }
    }
    ))
}
function DC() {
    if (typeof globalThis != "object")
        try {
            Object.defineProperty(Object.prototype, "__magic__", {
                get: function() {
                    return this
                },
                configurable: !0
            }),
            __magic__.globalThis = __magic__,
            delete Object.prototype.__magic__
        } catch {
            typeof self < "u" && (self.globalThis = self)
        }
}
function Ay(t) {
    if (!/^0x[a-fA-F0-9]{40}$/.test(t))
        throw new Error(`@supabase/auth-js: Address "${t}" is invalid.`);
    return t.toLowerCase()
}
function MC(t) {
    return parseInt(t, 16)
}
function FC(t) {
    const e = new TextEncoder().encode(t);
    return "0x" + Array.from(e, n=>n.toString(16).padStart(2, "0")).join("")
}
function BC(t) {
    var e;
    const {chainId: r, domain: n, expirationTime: s, issuedAt: i=new Date, nonce: o, notBefore: a, requestId: l, resources: u, scheme: c, uri: h, version: f} = t;
    {
        if (!Number.isInteger(r))
            throw new Error(`@supabase/auth-js: Invalid SIWE message field "chainId". Chain ID must be a EIP-155 chain ID. Provided value: ${r}`);
        if (!n)
            throw new Error('@supabase/auth-js: Invalid SIWE message field "domain". Domain must be provided.');
        if (o && o.length < 8)
            throw new Error(`@supabase/auth-js: Invalid SIWE message field "nonce". Nonce must be at least 8 characters. Provided value: ${o}`);
        if (!h)
            throw new Error('@supabase/auth-js: Invalid SIWE message field "uri". URI must be provided.');
        if (f !== "1")
            throw new Error(`@supabase/auth-js: Invalid SIWE message field "version". Version must be '1'. Provided value: ${f}`);
        if (!((e = t.statement) === null || e === void 0) && e.includes(`
`))
            throw new Error(`@supabase/auth-js: Invalid SIWE message field "statement". Statement must not include '\\n'. Provided value: ${t.statement}`)
    }
    const d = Ay(t.address)
      , y = c ? `${c}://${n}` : n
      , m = t.statement ? `${t.statement}
` : ""
      , w = `${y} wants you to sign in with your Ethereum account:
${d}

${m}`;
    let g = `URI: ${h}
Version: ${f}
Chain ID: ${r}${o ? `
Nonce: ${o}` : ""}
Issued At: ${i.toISOString()}`;
    if (s && (g += `
Expiration Time: ${s.toISOString()}`),
    a && (g += `
Not Before: ${a.toISOString()}`),
    l && (g += `
Request ID: ${l}`),
    u) {
        let p = `
Resources:`;
        for (const v of u) {
            if (!v || typeof v != "string")
                throw new Error(`@supabase/auth-js: Invalid SIWE message field "resources". Every resource must be a valid string. Provided value: ${v}`);
            p += `
- ${v}`
        }
        g += p
    }
    return `${w}
${g}`
}
class be extends Error {
    constructor({message: e, code: r, cause: n, name: s}) {
        var i;
        super(e, {
            cause: n
        }),
        this.__isWebAuthnError = !0,
        this.name = (i = s ?? (n instanceof Error ? n.name : void 0)) !== null && i !== void 0 ? i : "Unknown Error",
        this.code = r
    }
}
class Ua extends be {
    constructor(e, r) {
        super({
            code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
            cause: r,
            message: e
        }),
        this.name = "WebAuthnUnknownError",
        this.originalError = r
    }
}
function zC({error: t, options: e}) {
    var r, n, s;
    const {publicKey: i} = e;
    if (!i)
        throw Error("options was missing required publicKey property");
    if (t.name === "AbortError") {
        if (e.signal instanceof AbortSignal)
            return new be({
                message: "Registration ceremony was sent an abort signal",
                code: "ERROR_CEREMONY_ABORTED",
                cause: t
            })
    } else if (t.name === "ConstraintError") {
        if (((r = i.authenticatorSelection) === null || r === void 0 ? void 0 : r.requireResidentKey) === !0)
            return new be({
                message: "Discoverable credentials were required but no available authenticator supported it",
                code: "ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",
                cause: t
            });
        if (e.mediation === "conditional" && ((n = i.authenticatorSelection) === null || n === void 0 ? void 0 : n.userVerification) === "required")
            return new be({
                message: "User verification was required during automatic registration but it could not be performed",
                code: "ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",
                cause: t
            });
        if (((s = i.authenticatorSelection) === null || s === void 0 ? void 0 : s.userVerification) === "required")
            return new be({
                message: "User verification was required but no available authenticator supported it",
                code: "ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",
                cause: t
            })
    } else {
        if (t.name === "InvalidStateError")
            return new be({
                message: "The authenticator was previously registered",
                code: "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",
                cause: t
            });
        if (t.name === "NotAllowedError")
            return new be({
                message: t.message,
                code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
                cause: t
            });
        if (t.name === "NotSupportedError")
            return i.pubKeyCredParams.filter(a=>a.type === "public-key").length === 0 ? new be({
                message: 'No entry in pubKeyCredParams was of type "public-key"',
                code: "ERROR_MALFORMED_PUBKEYCREDPARAMS",
                cause: t
            }) : new be({
                message: "No available authenticator supported any of the specified pubKeyCredParams algorithms",
                code: "ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",
                cause: t
            });
        if (t.name === "SecurityError") {
            const o = window.location.hostname;
            if (Ny(o)) {
                if (i.rp.id !== o)
                    return new be({
                        message: `The RP ID "${i.rp.id}" is invalid for this domain`,
                        code: "ERROR_INVALID_RP_ID",
                        cause: t
                    })
            } else
                return new be({
                    message: `${window.location.hostname} is an invalid domain`,
                    code: "ERROR_INVALID_DOMAIN",
                    cause: t
                })
        } else if (t.name === "TypeError") {
            if (i.user.id.byteLength < 1 || i.user.id.byteLength > 64)
                return new be({
                    message: "User ID was not between 1 and 64 characters",
                    code: "ERROR_INVALID_USER_ID_LENGTH",
                    cause: t
                })
        } else if (t.name === "UnknownError")
            return new be({
                message: "The authenticator was unable to process the specified options, or could not create a new credential",
                code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
                cause: t
            })
    }
    return new be({
        message: "a Non-Webauthn related error has occurred",
        code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
        cause: t
    })
}
function VC({error: t, options: e}) {
    const {publicKey: r} = e;
    if (!r)
        throw Error("options was missing required publicKey property");
    if (t.name === "AbortError") {
        if (e.signal instanceof AbortSignal)
            return new be({
                message: "Authentication ceremony was sent an abort signal",
                code: "ERROR_CEREMONY_ABORTED",
                cause: t
            })
    } else {
        if (t.name === "NotAllowedError")
            return new be({
                message: t.message,
                code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
                cause: t
            });
        if (t.name === "SecurityError") {
            const n = window.location.hostname;
            if (Ny(n)) {
                if (r.rpId !== n)
                    return new be({
                        message: `The RP ID "${r.rpId}" is invalid for this domain`,
                        code: "ERROR_INVALID_RP_ID",
                        cause: t
                    })
            } else
                return new be({
                    message: `${window.location.hostname} is an invalid domain`,
                    code: "ERROR_INVALID_DOMAIN",
                    cause: t
                })
        } else if (t.name === "UnknownError")
            return new be({
                message: "The authenticator was unable to process the specified options, or could not create a new assertion signature",
                code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
                cause: t
            })
    }
    return new be({
        message: "a Non-Webauthn related error has occurred",
        code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
        cause: t
    })
}
class WC {
    createNewAbortSignal() {
        if (this.controller) {
            const r = new Error("Cancelling existing WebAuthn API call for new one");
            r.name = "AbortError",
            this.controller.abort(r)
        }
        const e = new AbortController;
        return this.controller = e,
        e.signal
    }
    cancelCeremony() {
        if (this.controller) {
            const e = new Error("Manually cancelling existing WebAuthn API call");
            e.name = "AbortError",
            this.controller.abort(e),
            this.controller = void 0
        }
    }
}
const HC = new WC;
function qC(t) {
    if (!t)
        throw new Error("Credential creation options are required");
    if (typeof PublicKeyCredential < "u" && "parseCreationOptionsFromJSON"in PublicKeyCredential && typeof PublicKeyCredential.parseCreationOptionsFromJSON == "function")
        return PublicKeyCredential.parseCreationOptionsFromJSON(t);
    const {challenge: e, user: r, excludeCredentials: n} = t
      , s = Vs(t, ["challenge", "user", "excludeCredentials"])
      , i = ys(e).buffer
      , o = Object.assign(Object.assign({}, r), {
        id: ys(r.id).buffer
    })
      , a = Object.assign(Object.assign({}, s), {
        challenge: i,
        user: o
    });
    if (n && n.length > 0) {
        a.excludeCredentials = new Array(n.length);
        for (let l = 0; l < n.length; l++) {
            const u = n[l];
            a.excludeCredentials[l] = Object.assign(Object.assign({}, u), {
                id: ys(u.id).buffer,
                type: u.type || "public-key",
                transports: u.transports
            })
        }
    }
    return a
}
function KC(t) {
    if (!t)
        throw new Error("Credential request options are required");
    if (typeof PublicKeyCredential < "u" && "parseRequestOptionsFromJSON"in PublicKeyCredential && typeof PublicKeyCredential.parseRequestOptionsFromJSON == "function")
        return PublicKeyCredential.parseRequestOptionsFromJSON(t);
    const {challenge: e, allowCredentials: r} = t
      , n = Vs(t, ["challenge", "allowCredentials"])
      , s = ys(e).buffer
      , i = Object.assign(Object.assign({}, n), {
        challenge: s
    });
    if (r && r.length > 0) {
        i.allowCredentials = new Array(r.length);
        for (let o = 0; o < r.length; o++) {
            const a = r[o];
            i.allowCredentials[o] = Object.assign(Object.assign({}, a), {
                id: ys(a.id).buffer,
                type: a.type || "public-key",
                transports: a.transports
            })
        }
    }
    return i
}
function GC(t) {
    var e;
    if ("toJSON"in t && typeof t.toJSON == "function")
        return t.toJSON();
    const r = t;
    return {
        id: t.id,
        rawId: t.id,
        response: {
            attestationObject: yn(new Uint8Array(t.response.attestationObject)),
            clientDataJSON: yn(new Uint8Array(t.response.clientDataJSON))
        },
        type: "public-key",
        clientExtensionResults: t.getClientExtensionResults(),
        authenticatorAttachment: (e = r.authenticatorAttachment) !== null && e !== void 0 ? e : void 0
    }
}
function QC(t) {
    var e;
    if ("toJSON"in t && typeof t.toJSON == "function")
        return t.toJSON();
    const r = t
      , n = t.getClientExtensionResults()
      , s = t.response;
    return {
        id: t.id,
        rawId: t.id,
        response: {
            authenticatorData: yn(new Uint8Array(s.authenticatorData)),
            clientDataJSON: yn(new Uint8Array(s.clientDataJSON)),
            signature: yn(new Uint8Array(s.signature)),
            userHandle: s.userHandle ? yn(new Uint8Array(s.userHandle)) : void 0
        },
        type: "public-key",
        clientExtensionResults: n,
        authenticatorAttachment: (e = r.authenticatorAttachment) !== null && e !== void 0 ? e : void 0
    }
}
function Ny(t) {
    return t === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(t)
}
function Sp() {
    var t, e;
    return !!(Pe() && "PublicKeyCredential"in window && window.PublicKeyCredential && "credentials"in navigator && typeof ((t = navigator == null ? void 0 : navigator.credentials) === null || t === void 0 ? void 0 : t.create) == "function" && typeof ((e = navigator == null ? void 0 : navigator.credentials) === null || e === void 0 ? void 0 : e.get) == "function")
}
async function JC(t) {
    try {
        const e = await navigator.credentials.create(t);
        return e ? e instanceof PublicKeyCredential ? {
            data: e,
            error: null
        } : {
            data: null,
            error: new Ua("Browser returned unexpected credential type",e)
        } : {
            data: null,
            error: new Ua("Empty credential response",e)
        }
    } catch (e) {
        return {
            data: null,
            error: zC({
                error: e,
                options: t
            })
        }
    }
}
async function YC(t) {
    try {
        const e = await navigator.credentials.get(t);
        return e ? e instanceof PublicKeyCredential ? {
            data: e,
            error: null
        } : {
            data: null,
            error: new Ua("Browser returned unexpected credential type",e)
        } : {
            data: null,
            error: new Ua("Empty credential response",e)
        }
    } catch (e) {
        return {
            data: null,
            error: VC({
                error: e,
                options: t
            })
        }
    }
}
const XC = {
    hints: ["security-key"],
    authenticatorSelection: {
        authenticatorAttachment: "cross-platform",
        requireResidentKey: !1,
        userVerification: "preferred",
        residentKey: "discouraged"
    },
    attestation: "direct"
}
  , ZC = {
    userVerification: "preferred",
    hints: ["security-key"],
    attestation: "direct"
};
function Da(...t) {
    const e = s=>s !== null && typeof s == "object" && !Array.isArray(s)
      , r = s=>s instanceof ArrayBuffer || ArrayBuffer.isView(s)
      , n = {};
    for (const s of t)
        if (s)
            for (const i in s) {
                const o = s[i];
                if (o !== void 0)
                    if (Array.isArray(o))
                        n[i] = o;
                    else if (r(o))
                        n[i] = o;
                    else if (e(o)) {
                        const a = n[i];
                        e(a) ? n[i] = Da(a, o) : n[i] = Da(o)
                    } else
                        n[i] = o
            }
    return n
}
function eP(t, e) {
    return Da(XC, t, e || {})
}
function tP(t, e) {
    return Da(ZC, t, e || {})
}
class rP {
    constructor(e) {
        this.client = e,
        this.enroll = this._enroll.bind(this),
        this.challenge = this._challenge.bind(this),
        this.verify = this._verify.bind(this),
        this.authenticate = this._authenticate.bind(this),
        this.register = this._register.bind(this)
    }
    async _enroll(e) {
        return this.client.mfa.enroll(Object.assign(Object.assign({}, e), {
            factorType: "webauthn"
        }))
    }
    async _challenge({factorId: e, webauthn: r, friendlyName: n, signal: s}, i) {
        try {
            const {data: o, error: a} = await this.client.mfa.challenge({
                factorId: e,
                webauthn: r
            });
            if (!o)
                return {
                    data: null,
                    error: a
                };
            const l = s ?? HC.createNewAbortSignal();
            if (o.webauthn.type === "create") {
                const {user: u} = o.webauthn.credential_options.publicKey;
                u.name || (u.name = `${u.id}:${n}`),
                u.displayName || (u.displayName = u.name)
            }
            switch (o.webauthn.type) {
            case "create":
                {
                    const u = eP(o.webauthn.credential_options.publicKey, i == null ? void 0 : i.create)
                      , {data: c, error: h} = await JC({
                        publicKey: u,
                        signal: l
                    });
                    return c ? {
                        data: {
                            factorId: e,
                            challengeId: o.id,
                            webauthn: {
                                type: o.webauthn.type,
                                credential_response: c
                            }
                        },
                        error: null
                    } : {
                        data: null,
                        error: h
                    }
                }
            case "request":
                {
                    const u = tP(o.webauthn.credential_options.publicKey, i == null ? void 0 : i.request)
                      , {data: c, error: h} = await YC(Object.assign(Object.assign({}, o.webauthn.credential_options), {
                        publicKey: u,
                        signal: l
                    }));
                    return c ? {
                        data: {
                            factorId: e,
                            challengeId: o.id,
                            webauthn: {
                                type: o.webauthn.type,
                                credential_response: c
                            }
                        },
                        error: null
                    } : {
                        data: null,
                        error: h
                    }
                }
            }
        } catch (o) {
            return M(o) ? {
                data: null,
                error: o
            } : {
                data: null,
                error: new pn("Unexpected error in challenge",o)
            }
        }
    }
    async _verify({challengeId: e, factorId: r, webauthn: n}) {
        return this.client.mfa.verify({
            factorId: r,
            challengeId: e,
            webauthn: n
        })
    }
    async _authenticate({factorId: e, webauthn: {rpId: r=typeof window < "u" ? window.location.hostname : void 0, rpOrigins: n=typeof window < "u" ? [window.location.origin] : void 0, signal: s}={}}, i) {
        if (!r)
            return {
                data: null,
                error: new Wi("rpId is required for WebAuthn authentication")
            };
        try {
            if (!Sp())
                return {
                    data: null,
                    error: new pn("Browser does not support WebAuthn",null)
                };
            const {data: o, error: a} = await this.challenge({
                factorId: e,
                webauthn: {
                    rpId: r,
                    rpOrigins: n
                },
                signal: s
            }, {
                request: i
            });
            if (!o)
                return {
                    data: null,
                    error: a
                };
            const {webauthn: l} = o;
            return this._verify({
                factorId: e,
                challengeId: o.challengeId,
                webauthn: {
                    type: l.type,
                    rpId: r,
                    rpOrigins: n,
                    credential_response: l.credential_response
                }
            })
        } catch (o) {
            return M(o) ? {
                data: null,
                error: o
            } : {
                data: null,
                error: new pn("Unexpected error in authenticate",o)
            }
        }
    }
    async _register({friendlyName: e, webauthn: {rpId: r=typeof window < "u" ? window.location.hostname : void 0, rpOrigins: n=typeof window < "u" ? [window.location.origin] : void 0, signal: s}={}}, i) {
        if (!r)
            return {
                data: null,
                error: new Wi("rpId is required for WebAuthn registration")
            };
        try {
            if (!Sp())
                return {
                    data: null,
                    error: new pn("Browser does not support WebAuthn",null)
                };
            const {data: o, error: a} = await this._enroll({
                friendlyName: e
            });
            if (!o)
                return await this.client.mfa.listFactors().then(c=>{
                    var h;
                    return (h = c.data) === null || h === void 0 ? void 0 : h.all.find(f=>f.factor_type === "webauthn" && f.friendly_name === e && f.status !== "unverified")
                }
                ).then(c=>c ? this.client.mfa.unenroll({
                    factorId: c == null ? void 0 : c.id
                }) : void 0),
                {
                    data: null,
                    error: a
                };
            const {data: l, error: u} = await this._challenge({
                factorId: o.id,
                friendlyName: o.friendly_name,
                webauthn: {
                    rpId: r,
                    rpOrigins: n
                },
                signal: s
            }, {
                create: i
            });
            return l ? this._verify({
                factorId: o.id,
                challengeId: l.challengeId,
                webauthn: {
                    rpId: r,
                    rpOrigins: n,
                    type: l.webauthn.type,
                    credential_response: l.webauthn.credential_response
                }
            }) : {
                data: null,
                error: u
            }
        } catch (o) {
            return M(o) ? {
                data: null,
                error: o
            } : {
                data: null,
                error: new pn("Unexpected error in register",o)
            }
        }
    }
}
DC();
const nP = {
    url: ZT,
    storageKey: eC,
    autoRefreshToken: !0,
    persistSession: !0,
    detectSessionInUrl: !0,
    headers: tC,
    flowType: "implicit",
    debug: !1,
    hasCustomAuthorizationHeader: !1,
    throwOnError: !1
};
async function kp(t, e, r) {
    return await r()
}
const Kn = {};
class Hi {
    get jwks() {
        var e, r;
        return (r = (e = Kn[this.storageKey]) === null || e === void 0 ? void 0 : e.jwks) !== null && r !== void 0 ? r : {
            keys: []
        }
    }
    set jwks(e) {
        Kn[this.storageKey] = Object.assign(Object.assign({}, Kn[this.storageKey]), {
            jwks: e
        })
    }
    get jwks_cached_at() {
        var e, r;
        return (r = (e = Kn[this.storageKey]) === null || e === void 0 ? void 0 : e.cachedAt) !== null && r !== void 0 ? r : Number.MIN_SAFE_INTEGER
    }
    set jwks_cached_at(e) {
        Kn[this.storageKey] = Object.assign(Object.assign({}, Kn[this.storageKey]), {
            cachedAt: e
        })
    }
    constructor(e) {
        var r, n, s;
        this.userStorage = null,
        this.memoryStorage = null,
        this.stateChangeEmitters = new Map,
        this.autoRefreshTicker = null,
        this.visibilityChangedCallback = null,
        this.refreshingDeferred = null,
        this.initializePromise = null,
        this.detectSessionInUrl = !0,
        this.hasCustomAuthorizationHeader = !1,
        this.suppressGetSessionWarning = !1,
        this.lockAcquired = !1,
        this.pendingInLock = [],
        this.broadcastChannel = null,
        this.logger = console.log;
        const i = Object.assign(Object.assign({}, nP), e);
        if (this.storageKey = i.storageKey,
        this.instanceID = (r = Hi.nextInstanceID[this.storageKey]) !== null && r !== void 0 ? r : 0,
        Hi.nextInstanceID[this.storageKey] = this.instanceID + 1,
        this.logDebugMessages = !!i.debug,
        typeof i.debug == "function" && (this.logger = i.debug),
        this.instanceID > 0 && Pe()) {
            const o = `${this._logPrefix()} Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.`;
            console.warn(o),
            this.logDebugMessages && console.trace(o)
        }
        if (this.persistSession = i.persistSession,
        this.autoRefreshToken = i.autoRefreshToken,
        this.admin = new $C({
            url: i.url,
            headers: i.headers,
            fetch: i.fetch
        }),
        this.url = i.url,
        this.headers = i.headers,
        this.fetch = Ry(i.fetch),
        this.lock = i.lock || kp,
        this.detectSessionInUrl = i.detectSessionInUrl,
        this.flowType = i.flowType,
        this.hasCustomAuthorizationHeader = i.hasCustomAuthorizationHeader,
        this.throwOnError = i.throwOnError,
        i.lock ? this.lock = i.lock : Pe() && (!((n = globalThis == null ? void 0 : globalThis.navigator) === null || n === void 0) && n.locks) ? this.lock = UC : this.lock = kp,
        this.jwks || (this.jwks = {
            keys: []
        },
        this.jwks_cached_at = Number.MIN_SAFE_INTEGER),
        this.mfa = {
            verify: this._verify.bind(this),
            enroll: this._enroll.bind(this),
            unenroll: this._unenroll.bind(this),
            challenge: this._challenge.bind(this),
            listFactors: this._listFactors.bind(this),
            challengeAndVerify: this._challengeAndVerify.bind(this),
            getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),
            webauthn: new rP(this)
        },
        this.oauth = {
            getAuthorizationDetails: this._getAuthorizationDetails.bind(this),
            approveAuthorization: this._approveAuthorization.bind(this),
            denyAuthorization: this._denyAuthorization.bind(this),
            listGrants: this._listOAuthGrants.bind(this),
            revokeGrant: this._revokeOAuthGrant.bind(this)
        },
        this.persistSession ? (i.storage ? this.storage = i.storage : Oy() ? this.storage = globalThis.localStorage : (this.memoryStorage = {},
        this.storage = Ep(this.memoryStorage)),
        i.userStorage && (this.userStorage = i.userStorage)) : (this.memoryStorage = {},
        this.storage = Ep(this.memoryStorage)),
        Pe() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
            try {
                this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey)
            } catch (o) {
                console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", o)
            }
            (s = this.broadcastChannel) === null || s === void 0 || s.addEventListener("message", async o=>{
                this._debug("received broadcast notification from other tab or client", o),
                await this._notifyAllSubscribers(o.data.event, o.data.session, !1)
            }
            )
        }
        this.initialize()
    }
    isThrowOnErrorEnabled() {
        return this.throwOnError
    }
    _returnResult(e) {
        if (this.throwOnError && e && e.error)
            throw e.error;
        return e
    }
    _logPrefix() {
        return `GoTrueClient@${this.storageKey}:${this.instanceID} (${Ty}) ${new Date().toISOString()}`
    }
    _debug(...e) {
        return this.logDebugMessages && this.logger(this._logPrefix(), ...e),
        this
    }
    async initialize() {
        return this.initializePromise ? await this.initializePromise : (this.initializePromise = (async()=>await this._acquireLock(-1, async()=>await this._initialize()))(),
        await this.initializePromise)
    }
    async _initialize() {
        var e;
        try {
            let r = {}
              , n = "none";
            if (Pe() && (r = mC(window.location.href),
            this._isImplicitGrantCallback(r) ? n = "implicit" : await this._isPKCECallback(r) && (n = "pkce")),
            Pe() && this.detectSessionInUrl && n !== "none") {
                const {data: s, error: i} = await this._getSessionFromURL(r, n);
                if (i) {
                    if (this._debug("#_initialize()", "error detecting session from URL", i),
                    aC(i)) {
                        const l = (e = i.details) === null || e === void 0 ? void 0 : e.code;
                        if (l === "identity_already_exists" || l === "identity_not_found" || l === "single_identity_not_deletable")
                            return {
                                error: i
                            }
                    }
                    return await this._removeSession(),
                    {
                        error: i
                    }
                }
                const {session: o, redirectType: a} = s;
                return this._debug("#_initialize()", "detected session in URL", o, "redirect type", a),
                await this._saveSession(o),
                setTimeout(async()=>{
                    a === "recovery" ? await this._notifyAllSubscribers("PASSWORD_RECOVERY", o) : await this._notifyAllSubscribers("SIGNED_IN", o)
                }
                , 0),
                {
                    error: null
                }
            }
            return await this._recoverAndRefresh(),
            {
                error: null
            }
        } catch (r) {
            return M(r) ? this._returnResult({
                error: r
            }) : this._returnResult({
                error: new pn("Unexpected error during initialization",r)
            })
        } finally {
            await this._handleVisibilityChange(),
            this._debug("#_initialize()", "end")
        }
    }
    async signInAnonymously(e) {
        var r, n, s;
        try {
            const i = await B(this.fetch, "POST", `${this.url}/signup`, {
                headers: this.headers,
                body: {
                    data: (n = (r = e == null ? void 0 : e.options) === null || r === void 0 ? void 0 : r.data) !== null && n !== void 0 ? n : {},
                    gotrue_meta_security: {
                        captcha_token: (s = e == null ? void 0 : e.options) === null || s === void 0 ? void 0 : s.captchaToken
                    }
                },
                xform: St
            })
              , {data: o, error: a} = i;
            if (a || !o)
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: a
                });
            const l = o.session
              , u = o.user;
            return o.session && (await this._saveSession(o.session),
            await this._notifyAllSubscribers("SIGNED_IN", l)),
            this._returnResult({
                data: {
                    user: u,
                    session: l
                },
                error: null
            })
        } catch (i) {
            if (M(i))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: i
                });
            throw i
        }
    }
    async signUp(e) {
        var r, n, s;
        try {
            let i;
            if ("email"in e) {
                const {email: c, password: h, options: f} = e;
                let d = null
                  , y = null;
                this.flowType === "pkce" && ([d,y] = await Wn(this.storage, this.storageKey)),
                i = await B(this.fetch, "POST", `${this.url}/signup`, {
                    headers: this.headers,
                    redirectTo: f == null ? void 0 : f.emailRedirectTo,
                    body: {
                        email: c,
                        password: h,
                        data: (r = f == null ? void 0 : f.data) !== null && r !== void 0 ? r : {},
                        gotrue_meta_security: {
                            captcha_token: f == null ? void 0 : f.captchaToken
                        },
                        code_challenge: d,
                        code_challenge_method: y
                    },
                    xform: St
                })
            } else if ("phone"in e) {
                const {phone: c, password: h, options: f} = e;
                i = await B(this.fetch, "POST", `${this.url}/signup`, {
                    headers: this.headers,
                    body: {
                        phone: c,
                        password: h,
                        data: (n = f == null ? void 0 : f.data) !== null && n !== void 0 ? n : {},
                        channel: (s = f == null ? void 0 : f.channel) !== null && s !== void 0 ? s : "sms",
                        gotrue_meta_security: {
                            captcha_token: f == null ? void 0 : f.captchaToken
                        }
                    },
                    xform: St
                })
            } else
                throw new Do("You must provide either an email or phone number and a password");
            const {data: o, error: a} = i;
            if (a || !o)
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: a
                });
            const l = o.session
              , u = o.user;
            return o.session && (await this._saveSession(o.session),
            await this._notifyAllSubscribers("SIGNED_IN", l)),
            this._returnResult({
                data: {
                    user: u,
                    session: l
                },
                error: null
            })
        } catch (i) {
            if (M(i))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: i
                });
            throw i
        }
    }
    async signInWithPassword(e) {
        try {
            let r;
            if ("email"in e) {
                const {email: i, password: o, options: a} = e;
                r = await B(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
                    headers: this.headers,
                    body: {
                        email: i,
                        password: o,
                        gotrue_meta_security: {
                            captcha_token: a == null ? void 0 : a.captchaToken
                        }
                    },
                    xform: _p
                })
            } else if ("phone"in e) {
                const {phone: i, password: o, options: a} = e;
                r = await B(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
                    headers: this.headers,
                    body: {
                        phone: i,
                        password: o,
                        gotrue_meta_security: {
                            captcha_token: a == null ? void 0 : a.captchaToken
                        }
                    },
                    xform: _p
                })
            } else
                throw new Do("You must provide either an email or phone number and a password");
            const {data: n, error: s} = r;
            if (s)
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: s
                });
            if (!n || !n.session || !n.user) {
                const i = new Vn;
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: i
                })
            }
            return n.session && (await this._saveSession(n.session),
            await this._notifyAllSubscribers("SIGNED_IN", n.session)),
            this._returnResult({
                data: Object.assign({
                    user: n.user,
                    session: n.session
                }, n.weak_password ? {
                    weakPassword: n.weak_password
                } : null),
                error: s
            })
        } catch (r) {
            if (M(r))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: r
                });
            throw r
        }
    }
    async signInWithOAuth(e) {
        var r, n, s, i;
        return await this._handleProviderSignIn(e.provider, {
            redirectTo: (r = e.options) === null || r === void 0 ? void 0 : r.redirectTo,
            scopes: (n = e.options) === null || n === void 0 ? void 0 : n.scopes,
            queryParams: (s = e.options) === null || s === void 0 ? void 0 : s.queryParams,
            skipBrowserRedirect: (i = e.options) === null || i === void 0 ? void 0 : i.skipBrowserRedirect
        })
    }
    async exchangeCodeForSession(e) {
        return await this.initializePromise,
        this._acquireLock(-1, async()=>this._exchangeCodeForSession(e))
    }
    async signInWithWeb3(e) {
        const {chain: r} = e;
        switch (r) {
        case "ethereum":
            return await this.signInWithEthereum(e);
        case "solana":
            return await this.signInWithSolana(e);
        default:
            throw new Error(`@supabase/auth-js: Unsupported chain "${r}"`)
        }
    }
    async signInWithEthereum(e) {
        var r, n, s, i, o, a, l, u, c, h, f;
        let d, y;
        if ("message"in e)
            d = e.message,
            y = e.signature;
        else {
            const {chain: m, wallet: w, statement: g, options: p} = e;
            let v;
            if (Pe())
                if (typeof w == "object")
                    v = w;
                else {
                    const j = window;
                    if ("ethereum"in j && typeof j.ethereum == "object" && "request"in j.ethereum && typeof j.ethereum.request == "function")
                        v = j.ethereum;
                    else
                        throw new Error("@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.")
                }
            else {
                if (typeof w != "object" || !(p != null && p.url))
                    throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
                v = w
            }
            const _ = new URL((r = p == null ? void 0 : p.url) !== null && r !== void 0 ? r : window.location.href)
              , E = await v.request({
                method: "eth_requestAccounts"
            }).then(j=>j).catch(()=>{
                throw new Error("@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid")
            }
            );
            if (!E || E.length === 0)
                throw new Error("@supabase/auth-js: No accounts available. Please ensure the wallet is connected.");
            const S = Ay(E[0]);
            let k = (n = p == null ? void 0 : p.signInWithEthereum) === null || n === void 0 ? void 0 : n.chainId;
            if (!k) {
                const j = await v.request({
                    method: "eth_chainId"
                });
                k = MC(j)
            }
            const P = {
                domain: _.host,
                address: S,
                statement: g,
                uri: _.href,
                version: "1",
                chainId: k,
                nonce: (s = p == null ? void 0 : p.signInWithEthereum) === null || s === void 0 ? void 0 : s.nonce,
                issuedAt: (o = (i = p == null ? void 0 : p.signInWithEthereum) === null || i === void 0 ? void 0 : i.issuedAt) !== null && o !== void 0 ? o : new Date,
                expirationTime: (a = p == null ? void 0 : p.signInWithEthereum) === null || a === void 0 ? void 0 : a.expirationTime,
                notBefore: (l = p == null ? void 0 : p.signInWithEthereum) === null || l === void 0 ? void 0 : l.notBefore,
                requestId: (u = p == null ? void 0 : p.signInWithEthereum) === null || u === void 0 ? void 0 : u.requestId,
                resources: (c = p == null ? void 0 : p.signInWithEthereum) === null || c === void 0 ? void 0 : c.resources
            };
            d = BC(P),
            y = await v.request({
                method: "personal_sign",
                params: [FC(d), S]
            })
        }
        try {
            const {data: m, error: w} = await B(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
                headers: this.headers,
                body: Object.assign({
                    chain: "ethereum",
                    message: d,
                    signature: y
                }, !((h = e.options) === null || h === void 0) && h.captchaToken ? {
                    gotrue_meta_security: {
                        captcha_token: (f = e.options) === null || f === void 0 ? void 0 : f.captchaToken
                    }
                } : null),
                xform: St
            });
            if (w)
                throw w;
            if (!m || !m.session || !m.user) {
                const g = new Vn;
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: g
                })
            }
            return m.session && (await this._saveSession(m.session),
            await this._notifyAllSubscribers("SIGNED_IN", m.session)),
            this._returnResult({
                data: Object.assign({}, m),
                error: w
            })
        } catch (m) {
            if (M(m))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: m
                });
            throw m
        }
    }
    async signInWithSolana(e) {
        var r, n, s, i, o, a, l, u, c, h, f, d;
        let y, m;
        if ("message"in e)
            y = e.message,
            m = e.signature;
        else {
            const {chain: w, wallet: g, statement: p, options: v} = e;
            let _;
            if (Pe())
                if (typeof g == "object")
                    _ = g;
                else {
                    const S = window;
                    if ("solana"in S && typeof S.solana == "object" && ("signIn"in S.solana && typeof S.solana.signIn == "function" || "signMessage"in S.solana && typeof S.solana.signMessage == "function"))
                        _ = S.solana;
                    else
                        throw new Error("@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.")
                }
            else {
                if (typeof g != "object" || !(v != null && v.url))
                    throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
                _ = g
            }
            const E = new URL((r = v == null ? void 0 : v.url) !== null && r !== void 0 ? r : window.location.href);
            if ("signIn"in _ && _.signIn) {
                const S = await _.signIn(Object.assign(Object.assign(Object.assign({
                    issuedAt: new Date().toISOString()
                }, v == null ? void 0 : v.signInWithSolana), {
                    version: "1",
                    domain: E.host,
                    uri: E.href
                }), p ? {
                    statement: p
                } : null));
                let k;
                if (Array.isArray(S) && S[0] && typeof S[0] == "object")
                    k = S[0];
                else if (S && typeof S == "object" && "signedMessage"in S && "signature"in S)
                    k = S;
                else
                    throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");
                if ("signedMessage"in k && "signature"in k && (typeof k.signedMessage == "string" || k.signedMessage instanceof Uint8Array) && k.signature instanceof Uint8Array)
                    y = typeof k.signedMessage == "string" ? k.signedMessage : new TextDecoder().decode(k.signedMessage),
                    m = k.signature;
                else
                    throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields")
            } else {
                if (!("signMessage"in _) || typeof _.signMessage != "function" || !("publicKey"in _) || typeof _ != "object" || !_.publicKey || !("toBase58"in _.publicKey) || typeof _.publicKey.toBase58 != "function")
                    throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");
                y = [`${E.host} wants you to sign in with your Solana account:`, _.publicKey.toBase58(), ...p ? ["", p, ""] : [""], "Version: 1", `URI: ${E.href}`, `Issued At: ${(s = (n = v == null ? void 0 : v.signInWithSolana) === null || n === void 0 ? void 0 : n.issuedAt) !== null && s !== void 0 ? s : new Date().toISOString()}`, ...!((i = v == null ? void 0 : v.signInWithSolana) === null || i === void 0) && i.notBefore ? [`Not Before: ${v.signInWithSolana.notBefore}`] : [], ...!((o = v == null ? void 0 : v.signInWithSolana) === null || o === void 0) && o.expirationTime ? [`Expiration Time: ${v.signInWithSolana.expirationTime}`] : [], ...!((a = v == null ? void 0 : v.signInWithSolana) === null || a === void 0) && a.chainId ? [`Chain ID: ${v.signInWithSolana.chainId}`] : [], ...!((l = v == null ? void 0 : v.signInWithSolana) === null || l === void 0) && l.nonce ? [`Nonce: ${v.signInWithSolana.nonce}`] : [], ...!((u = v == null ? void 0 : v.signInWithSolana) === null || u === void 0) && u.requestId ? [`Request ID: ${v.signInWithSolana.requestId}`] : [], ...!((h = (c = v == null ? void 0 : v.signInWithSolana) === null || c === void 0 ? void 0 : c.resources) === null || h === void 0) && h.length ? ["Resources", ...v.signInWithSolana.resources.map(k=>`- ${k}`)] : []].join(`
`);
                const S = await _.signMessage(new TextEncoder().encode(y), "utf8");
                if (!S || !(S instanceof Uint8Array))
                    throw new Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value");
                m = S
            }
        }
        try {
            const {data: w, error: g} = await B(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
                headers: this.headers,
                body: Object.assign({
                    chain: "solana",
                    message: y,
                    signature: yn(m)
                }, !((f = e.options) === null || f === void 0) && f.captchaToken ? {
                    gotrue_meta_security: {
                        captcha_token: (d = e.options) === null || d === void 0 ? void 0 : d.captchaToken
                    }
                } : null),
                xform: St
            });
            if (g)
                throw g;
            if (!w || !w.session || !w.user) {
                const p = new Vn;
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: p
                })
            }
            return w.session && (await this._saveSession(w.session),
            await this._notifyAllSubscribers("SIGNED_IN", w.session)),
            this._returnResult({
                data: Object.assign({}, w),
                error: g
            })
        } catch (w) {
            if (M(w))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: w
                });
            throw w
        }
    }
    async _exchangeCodeForSession(e) {
        const r = await ln(this.storage, `${this.storageKey}-code-verifier`)
          , [n,s] = (r ?? "").split("/");
        try {
            const {data: i, error: o} = await B(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, {
                headers: this.headers,
                body: {
                    auth_code: e,
                    code_verifier: n
                },
                xform: St
            });
            if (await Er(this.storage, `${this.storageKey}-code-verifier`),
            o)
                throw o;
            if (!i || !i.session || !i.user) {
                const a = new Vn;
                return this._returnResult({
                    data: {
                        user: null,
                        session: null,
                        redirectType: null
                    },
                    error: a
                })
            }
            return i.session && (await this._saveSession(i.session),
            await this._notifyAllSubscribers("SIGNED_IN", i.session)),
            this._returnResult({
                data: Object.assign(Object.assign({}, i), {
                    redirectType: s ?? null
                }),
                error: o
            })
        } catch (i) {
            if (M(i))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null,
                        redirectType: null
                    },
                    error: i
                });
            throw i
        }
    }
    async signInWithIdToken(e) {
        try {
            const {options: r, provider: n, token: s, access_token: i, nonce: o} = e
              , a = await B(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
                headers: this.headers,
                body: {
                    provider: n,
                    id_token: s,
                    access_token: i,
                    nonce: o,
                    gotrue_meta_security: {
                        captcha_token: r == null ? void 0 : r.captchaToken
                    }
                },
                xform: St
            })
              , {data: l, error: u} = a;
            if (u)
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: u
                });
            if (!l || !l.session || !l.user) {
                const c = new Vn;
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: c
                })
            }
            return l.session && (await this._saveSession(l.session),
            await this._notifyAllSubscribers("SIGNED_IN", l.session)),
            this._returnResult({
                data: l,
                error: u
            })
        } catch (r) {
            if (M(r))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: r
                });
            throw r
        }
    }
    async signInWithOtp(e) {
        var r, n, s, i, o;
        try {
            if ("email"in e) {
                const {email: a, options: l} = e;
                let u = null
                  , c = null;
                this.flowType === "pkce" && ([u,c] = await Wn(this.storage, this.storageKey));
                const {error: h} = await B(this.fetch, "POST", `${this.url}/otp`, {
                    headers: this.headers,
                    body: {
                        email: a,
                        data: (r = l == null ? void 0 : l.data) !== null && r !== void 0 ? r : {},
                        create_user: (n = l == null ? void 0 : l.shouldCreateUser) !== null && n !== void 0 ? n : !0,
                        gotrue_meta_security: {
                            captcha_token: l == null ? void 0 : l.captchaToken
                        },
                        code_challenge: u,
                        code_challenge_method: c
                    },
                    redirectTo: l == null ? void 0 : l.emailRedirectTo
                });
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: h
                })
            }
            if ("phone"in e) {
                const {phone: a, options: l} = e
                  , {data: u, error: c} = await B(this.fetch, "POST", `${this.url}/otp`, {
                    headers: this.headers,
                    body: {
                        phone: a,
                        data: (s = l == null ? void 0 : l.data) !== null && s !== void 0 ? s : {},
                        create_user: (i = l == null ? void 0 : l.shouldCreateUser) !== null && i !== void 0 ? i : !0,
                        gotrue_meta_security: {
                            captcha_token: l == null ? void 0 : l.captchaToken
                        },
                        channel: (o = l == null ? void 0 : l.channel) !== null && o !== void 0 ? o : "sms"
                    }
                });
                return this._returnResult({
                    data: {
                        user: null,
                        session: null,
                        messageId: u == null ? void 0 : u.message_id
                    },
                    error: c
                })
            }
            throw new Do("You must provide either an email or phone number.")
        } catch (a) {
            if (M(a))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: a
                });
            throw a
        }
    }
    async verifyOtp(e) {
        var r, n;
        try {
            let s, i;
            "options"in e && (s = (r = e.options) === null || r === void 0 ? void 0 : r.redirectTo,
            i = (n = e.options) === null || n === void 0 ? void 0 : n.captchaToken);
            const {data: o, error: a} = await B(this.fetch, "POST", `${this.url}/verify`, {
                headers: this.headers,
                body: Object.assign(Object.assign({}, e), {
                    gotrue_meta_security: {
                        captcha_token: i
                    }
                }),
                redirectTo: s,
                xform: St
            });
            if (a)
                throw a;
            if (!o)
                throw new Error("An error occurred on token verification.");
            const l = o.session
              , u = o.user;
            return l != null && l.access_token && (await this._saveSession(l),
            await this._notifyAllSubscribers(e.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN", l)),
            this._returnResult({
                data: {
                    user: u,
                    session: l
                },
                error: null
            })
        } catch (s) {
            if (M(s))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: s
                });
            throw s
        }
    }
    async signInWithSSO(e) {
        var r, n, s, i, o;
        try {
            let a = null
              , l = null;
            this.flowType === "pkce" && ([a,l] = await Wn(this.storage, this.storageKey));
            const u = await B(this.fetch, "POST", `${this.url}/sso`, {
                body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId"in e ? {
                    provider_id: e.providerId
                } : null), "domain"in e ? {
                    domain: e.domain
                } : null), {
                    redirect_to: (n = (r = e.options) === null || r === void 0 ? void 0 : r.redirectTo) !== null && n !== void 0 ? n : void 0
                }), !((s = e == null ? void 0 : e.options) === null || s === void 0) && s.captchaToken ? {
                    gotrue_meta_security: {
                        captcha_token: e.options.captchaToken
                    }
                } : null), {
                    skip_http_redirect: !0,
                    code_challenge: a,
                    code_challenge_method: l
                }),
                headers: this.headers,
                xform: AC
            });
            return !((i = u.data) === null || i === void 0) && i.url && Pe() && !(!((o = e.options) === null || o === void 0) && o.skipBrowserRedirect) && window.location.assign(u.data.url),
            this._returnResult(u)
        } catch (a) {
            if (M(a))
                return this._returnResult({
                    data: null,
                    error: a
                });
            throw a
        }
    }
    async reauthenticate() {
        return await this.initializePromise,
        await this._acquireLock(-1, async()=>await this._reauthenticate())
    }
    async _reauthenticate() {
        try {
            return await this._useSession(async e=>{
                const {data: {session: r}, error: n} = e;
                if (n)
                    throw n;
                if (!r)
                    throw new et;
                const {error: s} = await B(this.fetch, "GET", `${this.url}/reauthenticate`, {
                    headers: this.headers,
                    jwt: r.access_token
                });
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: s
                })
            }
            )
        } catch (e) {
            if (M(e))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: e
                });
            throw e
        }
    }
    async resend(e) {
        try {
            const r = `${this.url}/resend`;
            if ("email"in e) {
                const {email: n, type: s, options: i} = e
                  , {error: o} = await B(this.fetch, "POST", r, {
                    headers: this.headers,
                    body: {
                        email: n,
                        type: s,
                        gotrue_meta_security: {
                            captcha_token: i == null ? void 0 : i.captchaToken
                        }
                    },
                    redirectTo: i == null ? void 0 : i.emailRedirectTo
                });
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: o
                })
            } else if ("phone"in e) {
                const {phone: n, type: s, options: i} = e
                  , {data: o, error: a} = await B(this.fetch, "POST", r, {
                    headers: this.headers,
                    body: {
                        phone: n,
                        type: s,
                        gotrue_meta_security: {
                            captcha_token: i == null ? void 0 : i.captchaToken
                        }
                    }
                });
                return this._returnResult({
                    data: {
                        user: null,
                        session: null,
                        messageId: o == null ? void 0 : o.message_id
                    },
                    error: a
                })
            }
            throw new Do("You must provide either an email or phone number and a type")
        } catch (r) {
            if (M(r))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: r
                });
            throw r
        }
    }
    async getSession() {
        return await this.initializePromise,
        await this._acquireLock(-1, async()=>this._useSession(async r=>r))
    }
    async _acquireLock(e, r) {
        this._debug("#_acquireLock", "begin", e);
        try {
            if (this.lockAcquired) {
                const n = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve()
                  , s = (async()=>(await n,
                await r()))();
                return this.pendingInLock.push((async()=>{
                    try {
                        await s
                    } catch {}
                }
                )()),
                s
            }
            return await this.lock(`lock:${this.storageKey}`, e, async()=>{
                this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey);
                try {
                    this.lockAcquired = !0;
                    const n = r();
                    for (this.pendingInLock.push((async()=>{
                        try {
                            await n
                        } catch {}
                    }
                    )()),
                    await n; this.pendingInLock.length; ) {
                        const s = [...this.pendingInLock];
                        await Promise.all(s),
                        this.pendingInLock.splice(0, s.length)
                    }
                    return await n
                } finally {
                    this._debug("#_acquireLock", "lock released for storage key", this.storageKey),
                    this.lockAcquired = !1
                }
            }
            )
        } finally {
            this._debug("#_acquireLock", "end")
        }
    }
    async _useSession(e) {
        this._debug("#_useSession", "begin");
        try {
            const r = await this.__loadSession();
            return await e(r)
        } finally {
            this._debug("#_useSession", "end")
        }
    }
    async __loadSession() {
        this._debug("#__loadSession()", "begin"),
        this.lockAcquired || this._debug("#__loadSession()", "used outside of an acquired lock!", new Error().stack);
        try {
            let e = null;
            const r = await ln(this.storage, this.storageKey);
            if (this._debug("#getSession()", "session from storage", r),
            r !== null && (this._isValidSession(r) ? e = r : (this._debug("#getSession()", "session from storage is not valid"),
            await this._removeSession())),
            !e)
                return {
                    data: {
                        session: null
                    },
                    error: null
                };
            const n = e.expires_at ? e.expires_at * 1e3 - Date.now() < iu : !1;
            if (this._debug("#__loadSession()", `session has ${n ? "" : " not"} expired`, "expires_at", e.expires_at),
            !n) {
                if (this.userStorage) {
                    const o = await ln(this.userStorage, this.storageKey + "-user");
                    o != null && o.user ? e.user = o.user : e.user = lu()
                }
                if (this.storage.isServer && e.user && !e.user.__isUserNotAvailableProxy) {
                    const o = {
                        value: this.suppressGetSessionWarning
                    };
                    e.user = PC(e.user, o),
                    o.value && (this.suppressGetSessionWarning = !0)
                }
                return {
                    data: {
                        session: e
                    },
                    error: null
                }
            }
            const {data: s, error: i} = await this._callRefreshToken(e.refresh_token);
            return i ? this._returnResult({
                data: {
                    session: null
                },
                error: i
            }) : this._returnResult({
                data: {
                    session: s
                },
                error: null
            })
        } finally {
            this._debug("#__loadSession()", "end")
        }
    }
    async getUser(e) {
        return e ? await this._getUser(e) : (await this.initializePromise,
        await this._acquireLock(-1, async()=>await this._getUser()))
    }
    async _getUser(e) {
        try {
            return e ? await B(this.fetch, "GET", `${this.url}/user`, {
                headers: this.headers,
                jwt: e,
                xform: Rr
            }) : await this._useSession(async r=>{
                var n, s, i;
                const {data: o, error: a} = r;
                if (a)
                    throw a;
                return !(!((n = o.session) === null || n === void 0) && n.access_token) && !this.hasCustomAuthorizationHeader ? {
                    data: {
                        user: null
                    },
                    error: new et
                } : await B(this.fetch, "GET", `${this.url}/user`, {
                    headers: this.headers,
                    jwt: (i = (s = o.session) === null || s === void 0 ? void 0 : s.access_token) !== null && i !== void 0 ? i : void 0,
                    xform: Rr
                })
            }
            )
        } catch (r) {
            if (M(r))
                return oC(r) && (await this._removeSession(),
                await Er(this.storage, `${this.storageKey}-code-verifier`)),
                this._returnResult({
                    data: {
                        user: null
                    },
                    error: r
                });
            throw r
        }
    }
    async updateUser(e, r={}) {
        return await this.initializePromise,
        await this._acquireLock(-1, async()=>await this._updateUser(e, r))
    }
    async _updateUser(e, r={}) {
        try {
            return await this._useSession(async n=>{
                const {data: s, error: i} = n;
                if (i)
                    throw i;
                if (!s.session)
                    throw new et;
                const o = s.session;
                let a = null
                  , l = null;
                this.flowType === "pkce" && e.email != null && ([a,l] = await Wn(this.storage, this.storageKey));
                const {data: u, error: c} = await B(this.fetch, "PUT", `${this.url}/user`, {
                    headers: this.headers,
                    redirectTo: r == null ? void 0 : r.emailRedirectTo,
                    body: Object.assign(Object.assign({}, e), {
                        code_challenge: a,
                        code_challenge_method: l
                    }),
                    jwt: o.access_token,
                    xform: Rr
                });
                if (c)
                    throw c;
                return o.user = u.user,
                await this._saveSession(o),
                await this._notifyAllSubscribers("USER_UPDATED", o),
                this._returnResult({
                    data: {
                        user: o.user
                    },
                    error: null
                })
            }
            )
        } catch (n) {
            if (M(n))
                return this._returnResult({
                    data: {
                        user: null
                    },
                    error: n
                });
            throw n
        }
    }
    async setSession(e) {
        return await this.initializePromise,
        await this._acquireLock(-1, async()=>await this._setSession(e))
    }
    async _setSession(e) {
        try {
            if (!e.access_token || !e.refresh_token)
                throw new et;
            const r = Date.now() / 1e3;
            let n = r
              , s = !0
              , i = null;
            const {payload: o} = au(e.access_token);
            if (o.exp && (n = o.exp,
            s = n <= r),
            s) {
                const {data: a, error: l} = await this._callRefreshToken(e.refresh_token);
                if (l)
                    return this._returnResult({
                        data: {
                            user: null,
                            session: null
                        },
                        error: l
                    });
                if (!a)
                    return {
                        data: {
                            user: null,
                            session: null
                        },
                        error: null
                    };
                i = a
            } else {
                const {data: a, error: l} = await this._getUser(e.access_token);
                if (l)
                    throw l;
                i = {
                    access_token: e.access_token,
                    refresh_token: e.refresh_token,
                    user: a.user,
                    token_type: "bearer",
                    expires_in: n - r,
                    expires_at: n
                },
                await this._saveSession(i),
                await this._notifyAllSubscribers("SIGNED_IN", i)
            }
            return this._returnResult({
                data: {
                    user: i.user,
                    session: i
                },
                error: null
            })
        } catch (r) {
            if (M(r))
                return this._returnResult({
                    data: {
                        session: null,
                        user: null
                    },
                    error: r
                });
            throw r
        }
    }
    async refreshSession(e) {
        return await this.initializePromise,
        await this._acquireLock(-1, async()=>await this._refreshSession(e))
    }
    async _refreshSession(e) {
        try {
            return await this._useSession(async r=>{
                var n;
                if (!e) {
                    const {data: o, error: a} = r;
                    if (a)
                        throw a;
                    e = (n = o.session) !== null && n !== void 0 ? n : void 0
                }
                if (!(e != null && e.refresh_token))
                    throw new et;
                const {data: s, error: i} = await this._callRefreshToken(e.refresh_token);
                return i ? this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: i
                }) : s ? this._returnResult({
                    data: {
                        user: s.user,
                        session: s
                    },
                    error: null
                }) : this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: null
                })
            }
            )
        } catch (r) {
            if (M(r))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: r
                });
            throw r
        }
    }
    async _getSessionFromURL(e, r) {
        try {
            if (!Pe())
                throw new Mo("No browser detected.");
            if (e.error || e.error_description || e.error_code)
                throw new Mo(e.error_description || "Error in URL with unspecified error_description",{
                    error: e.error || "unspecified_error",
                    code: e.error_code || "unspecified_code"
                });
            switch (r) {
            case "implicit":
                if (this.flowType === "pkce")
                    throw new pp("Not a valid PKCE flow url.");
                break;
            case "pkce":
                if (this.flowType === "implicit")
                    throw new Mo("Not a valid implicit grant flow url.");
                break;
            default:
            }
            if (r === "pkce") {
                if (this._debug("#_initialize()", "begin", "is PKCE flow", !0),
                !e.code)
                    throw new pp("No code detected.");
                const {data: p, error: v} = await this._exchangeCodeForSession(e.code);
                if (v)
                    throw v;
                const _ = new URL(window.location.href);
                return _.searchParams.delete("code"),
                window.history.replaceState(window.history.state, "", _.toString()),
                {
                    data: {
                        session: p.session,
                        redirectType: null
                    },
                    error: null
                }
            }
            const {provider_token: n, provider_refresh_token: s, access_token: i, refresh_token: o, expires_in: a, expires_at: l, token_type: u} = e;
            if (!i || !a || !o || !u)
                throw new Mo("No session defined in URL");
            const c = Math.round(Date.now() / 1e3)
              , h = parseInt(a);
            let f = c + h;
            l && (f = parseInt(l));
            const d = f - c;
            d * 1e3 <= Gn && console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${d}s, should have been closer to ${h}s`);
            const y = f - h;
            c - y >= 120 ? console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", y, f, c) : c - y < 0 && console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew", y, f, c);
            const {data: m, error: w} = await this._getUser(i);
            if (w)
                throw w;
            const g = {
                provider_token: n,
                provider_refresh_token: s,
                access_token: i,
                expires_in: h,
                expires_at: f,
                refresh_token: o,
                token_type: u,
                user: m.user
            };
            return window.location.hash = "",
            this._debug("#_getSessionFromURL()", "clearing window.location.hash"),
            this._returnResult({
                data: {
                    session: g,
                    redirectType: e.type
                },
                error: null
            })
        } catch (n) {
            if (M(n))
                return this._returnResult({
                    data: {
                        session: null,
                        redirectType: null
                    },
                    error: n
                });
            throw n
        }
    }
    _isImplicitGrantCallback(e) {
        return !!(e.access_token || e.error_description)
    }
    async _isPKCECallback(e) {
        const r = await ln(this.storage, `${this.storageKey}-code-verifier`);
        return !!(e.code && r)
    }
    async signOut(e={
        scope: "global"
    }) {
        return await this.initializePromise,
        await this._acquireLock(-1, async()=>await this._signOut(e))
    }
    async _signOut({scope: e}={
        scope: "global"
    }) {
        return await this._useSession(async r=>{
            var n;
            const {data: s, error: i} = r;
            if (i)
                return this._returnResult({
                    error: i
                });
            const o = (n = s.session) === null || n === void 0 ? void 0 : n.access_token;
            if (o) {
                const {error: a} = await this.admin.signOut(o, e);
                if (a && !(iC(a) && (a.status === 404 || a.status === 401 || a.status === 403)))
                    return this._returnResult({
                        error: a
                    })
            }
            return e !== "others" && (await this._removeSession(),
            await Er(this.storage, `${this.storageKey}-code-verifier`)),
            this._returnResult({
                error: null
            })
        }
        )
    }
    onAuthStateChange(e) {
        const r = pC()
          , n = {
            id: r,
            callback: e,
            unsubscribe: ()=>{
                this._debug("#unsubscribe()", "state change callback with id removed", r),
                this.stateChangeEmitters.delete(r)
            }
        };
        return this._debug("#onAuthStateChange()", "registered callback with id", r),
        this.stateChangeEmitters.set(r, n),
        (async()=>(await this.initializePromise,
        await this._acquireLock(-1, async()=>{
            this._emitInitialSession(r)
        }
        )))(),
        {
            data: {
                subscription: n
            }
        }
    }
    async _emitInitialSession(e) {
        return await this._useSession(async r=>{
            var n, s;
            try {
                const {data: {session: i}, error: o} = r;
                if (o)
                    throw o;
                await ((n = this.stateChangeEmitters.get(e)) === null || n === void 0 ? void 0 : n.callback("INITIAL_SESSION", i)),
                this._debug("INITIAL_SESSION", "callback id", e, "session", i)
            } catch (i) {
                await ((s = this.stateChangeEmitters.get(e)) === null || s === void 0 ? void 0 : s.callback("INITIAL_SESSION", null)),
                this._debug("INITIAL_SESSION", "callback id", e, "error", i),
                console.error(i)
            }
        }
        )
    }
    async resetPasswordForEmail(e, r={}) {
        let n = null
          , s = null;
        this.flowType === "pkce" && ([n,s] = await Wn(this.storage, this.storageKey, !0));
        try {
            return await B(this.fetch, "POST", `${this.url}/recover`, {
                body: {
                    email: e,
                    code_challenge: n,
                    code_challenge_method: s,
                    gotrue_meta_security: {
                        captcha_token: r.captchaToken
                    }
                },
                headers: this.headers,
                redirectTo: r.redirectTo
            })
        } catch (i) {
            if (M(i))
                return this._returnResult({
                    data: null,
                    error: i
                });
            throw i
        }
    }
    async getUserIdentities() {
        var e;
        try {
            const {data: r, error: n} = await this.getUser();
            if (n)
                throw n;
            return this._returnResult({
                data: {
                    identities: (e = r.user.identities) !== null && e !== void 0 ? e : []
                },
                error: null
            })
        } catch (r) {
            if (M(r))
                return this._returnResult({
                    data: null,
                    error: r
                });
            throw r
        }
    }
    async linkIdentity(e) {
        return "token"in e ? this.linkIdentityIdToken(e) : this.linkIdentityOAuth(e)
    }
    async linkIdentityOAuth(e) {
        var r;
        try {
            const {data: n, error: s} = await this._useSession(async i=>{
                var o, a, l, u, c;
                const {data: h, error: f} = i;
                if (f)
                    throw f;
                const d = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, e.provider, {
                    redirectTo: (o = e.options) === null || o === void 0 ? void 0 : o.redirectTo,
                    scopes: (a = e.options) === null || a === void 0 ? void 0 : a.scopes,
                    queryParams: (l = e.options) === null || l === void 0 ? void 0 : l.queryParams,
                    skipBrowserRedirect: !0
                });
                return await B(this.fetch, "GET", d, {
                    headers: this.headers,
                    jwt: (c = (u = h.session) === null || u === void 0 ? void 0 : u.access_token) !== null && c !== void 0 ? c : void 0
                })
            }
            );
            if (s)
                throw s;
            return Pe() && !(!((r = e.options) === null || r === void 0) && r.skipBrowserRedirect) && window.location.assign(n == null ? void 0 : n.url),
            this._returnResult({
                data: {
                    provider: e.provider,
                    url: n == null ? void 0 : n.url
                },
                error: null
            })
        } catch (n) {
            if (M(n))
                return this._returnResult({
                    data: {
                        provider: e.provider,
                        url: null
                    },
                    error: n
                });
            throw n
        }
    }
    async linkIdentityIdToken(e) {
        return await this._useSession(async r=>{
            var n;
            try {
                const {error: s, data: {session: i}} = r;
                if (s)
                    throw s;
                const {options: o, provider: a, token: l, access_token: u, nonce: c} = e
                  , h = await B(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
                    headers: this.headers,
                    jwt: (n = i == null ? void 0 : i.access_token) !== null && n !== void 0 ? n : void 0,
                    body: {
                        provider: a,
                        id_token: l,
                        access_token: u,
                        nonce: c,
                        link_identity: !0,
                        gotrue_meta_security: {
                            captcha_token: o == null ? void 0 : o.captchaToken
                        }
                    },
                    xform: St
                })
                  , {data: f, error: d} = h;
                return d ? this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: d
                }) : !f || !f.session || !f.user ? this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: new Vn
                }) : (f.session && (await this._saveSession(f.session),
                await this._notifyAllSubscribers("USER_UPDATED", f.session)),
                this._returnResult({
                    data: f,
                    error: d
                }))
            } catch (s) {
                if (M(s))
                    return this._returnResult({
                        data: {
                            user: null,
                            session: null
                        },
                        error: s
                    });
                throw s
            }
        }
        )
    }
    async unlinkIdentity(e) {
        try {
            return await this._useSession(async r=>{
                var n, s;
                const {data: i, error: o} = r;
                if (o)
                    throw o;
                return await B(this.fetch, "DELETE", `${this.url}/user/identities/${e.identity_id}`, {
                    headers: this.headers,
                    jwt: (s = (n = i.session) === null || n === void 0 ? void 0 : n.access_token) !== null && s !== void 0 ? s : void 0
                })
            }
            )
        } catch (r) {
            if (M(r))
                return this._returnResult({
                    data: null,
                    error: r
                });
            throw r
        }
    }
    async _refreshAccessToken(e) {
        const r = `#_refreshAccessToken(${e.substring(0, 5)}...)`;
        this._debug(r, "begin");
        try {
            const n = Date.now();
            return await yC(async s=>(s > 0 && await vC(200 * Math.pow(2, s - 1)),
            this._debug(r, "refreshing attempt", s),
            await B(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, {
                body: {
                    refresh_token: e
                },
                headers: this.headers,
                xform: St
            })), (s,i)=>{
                const o = 200 * Math.pow(2, s);
                return i && ou(i) && Date.now() + o - n < Gn
            }
            )
        } catch (n) {
            if (this._debug(r, "error", n),
            M(n))
                return this._returnResult({
                    data: {
                        session: null,
                        user: null
                    },
                    error: n
                });
            throw n
        } finally {
            this._debug(r, "end")
        }
    }
    _isValidSession(e) {
        return typeof e == "object" && e !== null && "access_token"in e && "refresh_token"in e && "expires_at"in e
    }
    async _handleProviderSignIn(e, r) {
        const n = await this._getUrlForProvider(`${this.url}/authorize`, e, {
            redirectTo: r.redirectTo,
            scopes: r.scopes,
            queryParams: r.queryParams
        });
        return this._debug("#_handleProviderSignIn()", "provider", e, "options", r, "url", n),
        Pe() && !r.skipBrowserRedirect && window.location.assign(n),
        {
            data: {
                provider: e,
                url: n
            },
            error: null
        }
    }
    async _recoverAndRefresh() {
        var e, r;
        const n = "#_recoverAndRefresh()";
        this._debug(n, "begin");
        try {
            const s = await ln(this.storage, this.storageKey);
            if (s && this.userStorage) {
                let o = await ln(this.userStorage, this.storageKey + "-user");
                !this.storage.isServer && Object.is(this.storage, this.userStorage) && !o && (o = {
                    user: s.user
                },
                await Qn(this.userStorage, this.storageKey + "-user", o)),
                s.user = (e = o == null ? void 0 : o.user) !== null && e !== void 0 ? e : lu()
            } else if (s && !s.user && !s.user) {
                const o = await ln(this.storage, this.storageKey + "-user");
                o && (o != null && o.user) ? (s.user = o.user,
                await Er(this.storage, this.storageKey + "-user"),
                await Qn(this.storage, this.storageKey, s)) : s.user = lu()
            }
            if (this._debug(n, "session from storage", s),
            !this._isValidSession(s)) {
                this._debug(n, "session is not valid"),
                s !== null && await this._removeSession();
                return
            }
            const i = ((r = s.expires_at) !== null && r !== void 0 ? r : 1 / 0) * 1e3 - Date.now() < iu;
            if (this._debug(n, `session has ${i ? "" : " not"} expired with margin of ${iu}s`),
            i) {
                if (this.autoRefreshToken && s.refresh_token) {
                    const {error: o} = await this._callRefreshToken(s.refresh_token);
                    o && (console.error(o),
                    ou(o) || (this._debug(n, "refresh failed with a non-retryable error, removing the session", o),
                    await this._removeSession()))
                }
            } else if (s.user && s.user.__isUserNotAvailableProxy === !0)
                try {
                    const {data: o, error: a} = await this._getUser(s.access_token);
                    !a && (o != null && o.user) ? (s.user = o.user,
                    await this._saveSession(s),
                    await this._notifyAllSubscribers("SIGNED_IN", s)) : this._debug(n, "could not get user data, skipping SIGNED_IN notification")
                } catch (o) {
                    console.error("Error getting user data:", o),
                    this._debug(n, "error getting user data, skipping SIGNED_IN notification", o)
                }
            else
                await this._notifyAllSubscribers("SIGNED_IN", s)
        } catch (s) {
            this._debug(n, "error", s),
            console.error(s);
            return
        } finally {
            this._debug(n, "end")
        }
    }
    async _callRefreshToken(e) {
        var r, n;
        if (!e)
            throw new et;
        if (this.refreshingDeferred)
            return this.refreshingDeferred.promise;
        const s = `#_callRefreshToken(${e.substring(0, 5)}...)`;
        this._debug(s, "begin");
        try {
            this.refreshingDeferred = new gl;
            const {data: i, error: o} = await this._refreshAccessToken(e);
            if (o)
                throw o;
            if (!i.session)
                throw new et;
            await this._saveSession(i.session),
            await this._notifyAllSubscribers("TOKEN_REFRESHED", i.session);
            const a = {
                data: i.session,
                error: null
            };
            return this.refreshingDeferred.resolve(a),
            a
        } catch (i) {
            if (this._debug(s, "error", i),
            M(i)) {
                const o = {
                    data: null,
                    error: i
                };
                return ou(i) || await this._removeSession(),
                (r = this.refreshingDeferred) === null || r === void 0 || r.resolve(o),
                o
            }
            throw (n = this.refreshingDeferred) === null || n === void 0 || n.reject(i),
            i
        } finally {
            this.refreshingDeferred = null,
            this._debug(s, "end")
        }
    }
    async _notifyAllSubscribers(e, r, n=!0) {
        const s = `#_notifyAllSubscribers(${e})`;
        this._debug(s, "begin", r, `broadcast = ${n}`);
        try {
            this.broadcastChannel && n && this.broadcastChannel.postMessage({
                event: e,
                session: r
            });
            const i = []
              , o = Array.from(this.stateChangeEmitters.values()).map(async a=>{
                try {
                    await a.callback(e, r)
                } catch (l) {
                    i.push(l)
                }
            }
            );
            if (await Promise.all(o),
            i.length > 0) {
                for (let a = 0; a < i.length; a += 1)
                    console.error(i[a]);
                throw i[0]
            }
        } finally {
            this._debug(s, "end")
        }
    }
    async _saveSession(e) {
        this._debug("#_saveSession()", e),
        this.suppressGetSessionWarning = !0;
        const r = Object.assign({}, e)
          , n = r.user && r.user.__isUserNotAvailableProxy === !0;
        if (this.userStorage) {
            !n && r.user && await Qn(this.userStorage, this.storageKey + "-user", {
                user: r.user
            });
            const s = Object.assign({}, r);
            delete s.user;
            const i = wp(s);
            await Qn(this.storage, this.storageKey, i)
        } else {
            const s = wp(r);
            await Qn(this.storage, this.storageKey, s)
        }
    }
    async _removeSession() {
        this._debug("#_removeSession()"),
        await Er(this.storage, this.storageKey),
        await Er(this.storage, this.storageKey + "-code-verifier"),
        await Er(this.storage, this.storageKey + "-user"),
        this.userStorage && await Er(this.userStorage, this.storageKey + "-user"),
        await this._notifyAllSubscribers("SIGNED_OUT", null)
    }
    _removeVisibilityChangedCallback() {
        this._debug("#_removeVisibilityChangedCallback()");
        const e = this.visibilityChangedCallback;
        this.visibilityChangedCallback = null;
        try {
            e && Pe() && (window != null && window.removeEventListener) && window.removeEventListener("visibilitychange", e)
        } catch (r) {
            console.error("removing visibilitychange callback failed", r)
        }
    }
    async _startAutoRefresh() {
        await this._stopAutoRefresh(),
        this._debug("#_startAutoRefresh()");
        const e = setInterval(()=>this._autoRefreshTokenTick(), Gn);
        this.autoRefreshTicker = e,
        e && typeof e == "object" && typeof e.unref == "function" ? e.unref() : typeof Deno < "u" && typeof Deno.unrefTimer == "function" && Deno.unrefTimer(e),
        setTimeout(async()=>{
            await this.initializePromise,
            await this._autoRefreshTokenTick()
        }
        , 0)
    }
    async _stopAutoRefresh() {
        this._debug("#_stopAutoRefresh()");
        const e = this.autoRefreshTicker;
        this.autoRefreshTicker = null,
        e && clearInterval(e)
    }
    async startAutoRefresh() {
        this._removeVisibilityChangedCallback(),
        await this._startAutoRefresh()
    }
    async stopAutoRefresh() {
        this._removeVisibilityChangedCallback(),
        await this._stopAutoRefresh()
    }
    async _autoRefreshTokenTick() {
        this._debug("#_autoRefreshTokenTick()", "begin");
        try {
            await this._acquireLock(0, async()=>{
                try {
                    const e = Date.now();
                    try {
                        return await this._useSession(async r=>{
                            const {data: {session: n}} = r;
                            if (!n || !n.refresh_token || !n.expires_at) {
                                this._debug("#_autoRefreshTokenTick()", "no session");
                                return
                            }
                            const s = Math.floor((n.expires_at * 1e3 - e) / Gn);
                            this._debug("#_autoRefreshTokenTick()", `access token expires in ${s} ticks, a tick lasts ${Gn}ms, refresh threshold is ${Cc} ticks`),
                            s <= Cc && await this._callRefreshToken(n.refresh_token)
                        }
                        )
                    } catch (r) {
                        console.error("Auto refresh tick failed with error. This is likely a transient error.", r)
                    }
                } finally {
                    this._debug("#_autoRefreshTokenTick()", "end")
                }
            }
            )
        } catch (e) {
            if (e.isAcquireTimeout || e instanceof jy)
                this._debug("auto refresh token tick lock not available");
            else
                throw e
        }
    }
    async _handleVisibilityChange() {
        if (this._debug("#_handleVisibilityChange()"),
        !Pe() || !(window != null && window.addEventListener))
            return this.autoRefreshToken && this.startAutoRefresh(),
            !1;
        try {
            this.visibilityChangedCallback = async()=>await this._onVisibilityChanged(!1),
            window == null || window.addEventListener("visibilitychange", this.visibilityChangedCallback),
            await this._onVisibilityChanged(!0)
        } catch (e) {
            console.error("_handleVisibilityChange", e)
        }
    }
    async _onVisibilityChanged(e) {
        const r = `#_onVisibilityChanged(${e})`;
        this._debug(r, "visibilityState", document.visibilityState),
        document.visibilityState === "visible" ? (this.autoRefreshToken && this._startAutoRefresh(),
        e || (await this.initializePromise,
        await this._acquireLock(-1, async()=>{
            if (document.visibilityState !== "visible") {
                this._debug(r, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");
                return
            }
            await this._recoverAndRefresh()
        }
        ))) : document.visibilityState === "hidden" && this.autoRefreshToken && this._stopAutoRefresh()
    }
    async _getUrlForProvider(e, r, n) {
        const s = [`provider=${encodeURIComponent(r)}`];
        if (n != null && n.redirectTo && s.push(`redirect_to=${encodeURIComponent(n.redirectTo)}`),
        n != null && n.scopes && s.push(`scopes=${encodeURIComponent(n.scopes)}`),
        this.flowType === "pkce") {
            const [i,o] = await Wn(this.storage, this.storageKey)
              , a = new URLSearchParams({
                code_challenge: `${encodeURIComponent(i)}`,
                code_challenge_method: `${encodeURIComponent(o)}`
            });
            s.push(a.toString())
        }
        if (n != null && n.queryParams) {
            const i = new URLSearchParams(n.queryParams);
            s.push(i.toString())
        }
        return n != null && n.skipBrowserRedirect && s.push(`skip_http_redirect=${n.skipBrowserRedirect}`),
        `${e}?${s.join("&")}`
    }
    async _unenroll(e) {
        try {
            return await this._useSession(async r=>{
                var n;
                const {data: s, error: i} = r;
                return i ? this._returnResult({
                    data: null,
                    error: i
                }) : await B(this.fetch, "DELETE", `${this.url}/factors/${e.factorId}`, {
                    headers: this.headers,
                    jwt: (n = s == null ? void 0 : s.session) === null || n === void 0 ? void 0 : n.access_token
                })
            }
            )
        } catch (r) {
            if (M(r))
                return this._returnResult({
                    data: null,
                    error: r
                });
            throw r
        }
    }
    async _enroll(e) {
        try {
            return await this._useSession(async r=>{
                var n, s;
                const {data: i, error: o} = r;
                if (o)
                    return this._returnResult({
                        data: null,
                        error: o
                    });
                const a = Object.assign({
                    friendly_name: e.friendlyName,
                    factor_type: e.factorType
                }, e.factorType === "phone" ? {
                    phone: e.phone
                } : e.factorType === "totp" ? {
                    issuer: e.issuer
                } : {})
                  , {data: l, error: u} = await B(this.fetch, "POST", `${this.url}/factors`, {
                    body: a,
                    headers: this.headers,
                    jwt: (n = i == null ? void 0 : i.session) === null || n === void 0 ? void 0 : n.access_token
                });
                return u ? this._returnResult({
                    data: null,
                    error: u
                }) : (e.factorType === "totp" && l.type === "totp" && (!((s = l == null ? void 0 : l.totp) === null || s === void 0) && s.qr_code) && (l.totp.qr_code = `data:image/svg+xml;utf-8,${l.totp.qr_code}`),
                this._returnResult({
                    data: l,
                    error: null
                }))
            }
            )
        } catch (r) {
            if (M(r))
                return this._returnResult({
                    data: null,
                    error: r
                });
            throw r
        }
    }
    async _verify(e) {
        return this._acquireLock(-1, async()=>{
            try {
                return await this._useSession(async r=>{
                    var n;
                    const {data: s, error: i} = r;
                    if (i)
                        return this._returnResult({
                            data: null,
                            error: i
                        });
                    const o = Object.assign({
                        challenge_id: e.challengeId
                    }, "webauthn"in e ? {
                        webauthn: Object.assign(Object.assign({}, e.webauthn), {
                            credential_response: e.webauthn.type === "create" ? GC(e.webauthn.credential_response) : QC(e.webauthn.credential_response)
                        })
                    } : {
                        code: e.code
                    })
                      , {data: a, error: l} = await B(this.fetch, "POST", `${this.url}/factors/${e.factorId}/verify`, {
                        body: o,
                        headers: this.headers,
                        jwt: (n = s == null ? void 0 : s.session) === null || n === void 0 ? void 0 : n.access_token
                    });
                    return l ? this._returnResult({
                        data: null,
                        error: l
                    }) : (await this._saveSession(Object.assign({
                        expires_at: Math.round(Date.now() / 1e3) + a.expires_in
                    }, a)),
                    await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", a),
                    this._returnResult({
                        data: a,
                        error: l
                    }))
                }
                )
            } catch (r) {
                if (M(r))
                    return this._returnResult({
                        data: null,
                        error: r
                    });
                throw r
            }
        }
        )
    }
    async _challenge(e) {
        return this._acquireLock(-1, async()=>{
            try {
                return await this._useSession(async r=>{
                    var n;
                    const {data: s, error: i} = r;
                    if (i)
                        return this._returnResult({
                            data: null,
                            error: i
                        });
                    const o = await B(this.fetch, "POST", `${this.url}/factors/${e.factorId}/challenge`, {
                        body: e,
                        headers: this.headers,
                        jwt: (n = s == null ? void 0 : s.session) === null || n === void 0 ? void 0 : n.access_token
                    });
                    if (o.error)
                        return o;
                    const {data: a} = o;
                    if (a.type !== "webauthn")
                        return {
                            data: a,
                            error: null
                        };
                    switch (a.webauthn.type) {
                    case "create":
                        return {
                            data: Object.assign(Object.assign({}, a), {
                                webauthn: Object.assign(Object.assign({}, a.webauthn), {
                                    credential_options: Object.assign(Object.assign({}, a.webauthn.credential_options), {
                                        publicKey: qC(a.webauthn.credential_options.publicKey)
                                    })
                                })
                            }),
                            error: null
                        };
                    case "request":
                        return {
                            data: Object.assign(Object.assign({}, a), {
                                webauthn: Object.assign(Object.assign({}, a.webauthn), {
                                    credential_options: Object.assign(Object.assign({}, a.webauthn.credential_options), {
                                        publicKey: KC(a.webauthn.credential_options.publicKey)
                                    })
                                })
                            }),
                            error: null
                        }
                    }
                }
                )
            } catch (r) {
                if (M(r))
                    return this._returnResult({
                        data: null,
                        error: r
                    });
                throw r
            }
        }
        )
    }
    async _challengeAndVerify(e) {
        const {data: r, error: n} = await this._challenge({
            factorId: e.factorId
        });
        return n ? this._returnResult({
            data: null,
            error: n
        }) : await this._verify({
            factorId: e.factorId,
            challengeId: r.id,
            code: e.code
        })
    }
    async _listFactors() {
        var e;
        const {data: {user: r}, error: n} = await this.getUser();
        if (n)
            return {
                data: null,
                error: n
            };
        const s = {
            all: [],
            phone: [],
            totp: [],
            webauthn: []
        };
        for (const i of (e = r == null ? void 0 : r.factors) !== null && e !== void 0 ? e : [])
            s.all.push(i),
            i.status === "verified" && s[i.factor_type].push(i);
        return {
            data: s,
            error: null
        }
    }
    async _getAuthenticatorAssuranceLevel() {
        var e, r;
        const {data: {session: n}, error: s} = await this.getSession();
        if (s)
            return this._returnResult({
                data: null,
                error: s
            });
        if (!n)
            return {
                data: {
                    currentLevel: null,
                    nextLevel: null,
                    currentAuthenticationMethods: []
                },
                error: null
            };
        const {payload: i} = au(n.access_token);
        let o = null;
        i.aal && (o = i.aal);
        let a = o;
        ((r = (e = n.user.factors) === null || e === void 0 ? void 0 : e.filter(c=>c.status === "verified")) !== null && r !== void 0 ? r : []).length > 0 && (a = "aal2");
        const u = i.amr || [];
        return {
            data: {
                currentLevel: o,
                nextLevel: a,
                currentAuthenticationMethods: u
            },
            error: null
        }
    }
    async _getAuthorizationDetails(e) {
        try {
            return await this._useSession(async r=>{
                const {data: {session: n}, error: s} = r;
                return s ? this._returnResult({
                    data: null,
                    error: s
                }) : n ? await B(this.fetch, "GET", `${this.url}/oauth/authorizations/${e}`, {
                    headers: this.headers,
                    jwt: n.access_token,
                    xform: i=>({
                        data: i,
                        error: null
                    })
                }) : this._returnResult({
                    data: null,
                    error: new et
                })
            }
            )
        } catch (r) {
            if (M(r))
                return this._returnResult({
                    data: null,
                    error: r
                });
            throw r
        }
    }
    async _approveAuthorization(e, r) {
        try {
            return await this._useSession(async n=>{
                const {data: {session: s}, error: i} = n;
                if (i)
                    return this._returnResult({
                        data: null,
                        error: i
                    });
                if (!s)
                    return this._returnResult({
                        data: null,
                        error: new et
                    });
                const o = await B(this.fetch, "POST", `${this.url}/oauth/authorizations/${e}/consent`, {
                    headers: this.headers,
                    jwt: s.access_token,
                    body: {
                        action: "approve"
                    },
                    xform: a=>({
                        data: a,
                        error: null
                    })
                });
                return o.data && o.data.redirect_url && Pe() && !(r != null && r.skipBrowserRedirect) && window.location.assign(o.data.redirect_url),
                o
            }
            )
        } catch (n) {
            if (M(n))
                return this._returnResult({
                    data: null,
                    error: n
                });
            throw n
        }
    }
    async _denyAuthorization(e, r) {
        try {
            return await this._useSession(async n=>{
                const {data: {session: s}, error: i} = n;
                if (i)
                    return this._returnResult({
                        data: null,
                        error: i
                    });
                if (!s)
                    return this._returnResult({
                        data: null,
                        error: new et
                    });
                const o = await B(this.fetch, "POST", `${this.url}/oauth/authorizations/${e}/consent`, {
                    headers: this.headers,
                    jwt: s.access_token,
                    body: {
                        action: "deny"
                    },
                    xform: a=>({
                        data: a,
                        error: null
                    })
                });
                return o.data && o.data.redirect_url && Pe() && !(r != null && r.skipBrowserRedirect) && window.location.assign(o.data.redirect_url),
                o
            }
            )
        } catch (n) {
            if (M(n))
                return this._returnResult({
                    data: null,
                    error: n
                });
            throw n
        }
    }
    async _listOAuthGrants() {
        try {
            return await this._useSession(async e=>{
                const {data: {session: r}, error: n} = e;
                return n ? this._returnResult({
                    data: null,
                    error: n
                }) : r ? await B(this.fetch, "GET", `${this.url}/user/oauth/grants`, {
                    headers: this.headers,
                    jwt: r.access_token,
                    xform: s=>({
                        data: s,
                        error: null
                    })
                }) : this._returnResult({
                    data: null,
                    error: new et
                })
            }
            )
        } catch (e) {
            if (M(e))
                return this._returnResult({
                    data: null,
                    error: e
                });
            throw e
        }
    }
    async _revokeOAuthGrant(e) {
        try {
            return await this._useSession(async r=>{
                const {data: {session: n}, error: s} = r;
                return s ? this._returnResult({
                    data: null,
                    error: s
                }) : n ? (await B(this.fetch, "DELETE", `${this.url}/user/oauth/grants`, {
                    headers: this.headers,
                    jwt: n.access_token,
                    query: {
                        client_id: e.clientId
                    },
                    noResolveJson: !0
                }),
                {
                    data: {},
                    error: null
                }) : this._returnResult({
                    data: null,
                    error: new et
                })
            }
            )
        } catch (r) {
            if (M(r))
                return this._returnResult({
                    data: null,
                    error: r
                });
            throw r
        }
    }
    async fetchJwk(e, r={
        keys: []
    }) {
        let n = r.keys.find(a=>a.kid === e);
        if (n)
            return n;
        const s = Date.now();
        if (n = this.jwks.keys.find(a=>a.kid === e),
        n && this.jwks_cached_at + nC > s)
            return n;
        const {data: i, error: o} = await B(this.fetch, "GET", `${this.url}/.well-known/jwks.json`, {
            headers: this.headers
        });
        if (o)
            throw o;
        return !i.keys || i.keys.length === 0 || (this.jwks = i,
        this.jwks_cached_at = s,
        n = i.keys.find(a=>a.kid === e),
        !n) ? null : n
    }
    async getClaims(e, r={}) {
        try {
            let n = e;
            if (!n) {
                const {data: d, error: y} = await this.getSession();
                if (y || !d.session)
                    return this._returnResult({
                        data: null,
                        error: y
                    });
                n = d.session.access_token
            }
            const {header: s, payload: i, signature: o, raw: {header: a, payload: l}} = au(n);
            r != null && r.allowExpired || kC(i.exp);
            const u = !s.alg || s.alg.startsWith("HS") || !s.kid || !("crypto"in globalThis && "subtle"in globalThis.crypto) ? null : await this.fetchJwk(s.kid, r != null && r.keys ? {
                keys: r.keys
            } : r == null ? void 0 : r.jwks);
            if (!u) {
                const {error: d} = await this.getUser(n);
                if (d)
                    throw d;
                return {
                    data: {
                        claims: i,
                        header: s,
                        signature: o
                    },
                    error: null
                }
            }
            const c = TC(s.alg)
              , h = await crypto.subtle.importKey("jwk", u, c, !0, ["verify"]);
            if (!await crypto.subtle.verify(c, h, o, hC(`${a}.${l}`)))
                throw new Rc("Invalid JWT signature");
            return {
                data: {
                    claims: i,
                    header: s,
                    signature: o
                },
                error: null
            }
        } catch (n) {
            if (M(n))
                return this._returnResult({
                    data: null,
                    error: n
                });
            throw n
        }
    }
}
Hi.nextInstanceID = {};
const sP = Hi;
class iP extends sP {
    constructor(e) {
        super(e)
    }
}
class oP {
    constructor(e, r, n) {
        var s, i, o;
        this.supabaseUrl = e,
        this.supabaseKey = r;
        const a = XT(e);
        if (!r)
            throw new Error("supabaseKey is required.");
        this.realtimeUrl = new URL("realtime/v1",a),
        this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace("http", "ws"),
        this.authUrl = new URL("auth/v1",a),
        this.storageUrl = new URL("storage/v1",a),
        this.functionsUrl = new URL("functions/v1",a);
        const l = `sb-${a.hostname.split(".")[0]}-auth-token`
          , u = {
            db: WT,
            realtime: qT,
            auth: Object.assign(Object.assign({}, HT), {
                storageKey: l
            }),
            global: VT
        }
          , c = YT(n ?? {}, u);
        this.storageKey = (s = c.auth.storageKey) !== null && s !== void 0 ? s : "",
        this.headers = (i = c.global.headers) !== null && i !== void 0 ? i : {},
        c.accessToken ? (this.accessToken = c.accessToken,
        this.auth = new Proxy({},{
            get: (h,f)=>{
                throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(f)} is not possible`)
            }
        })) : this.auth = this._initSupabaseAuthClient((o = c.auth) !== null && o !== void 0 ? o : {}, this.headers, c.global.fetch),
        this.fetch = QT(r, this._getAccessToken.bind(this), c.global.fetch),
        this.realtime = this._initRealtimeClient(Object.assign({
            headers: this.headers,
            accessToken: this._getAccessToken.bind(this)
        }, c.realtime)),
        this.accessToken && this.accessToken().then(h=>this.realtime.setAuth(h)).catch(h=>console.warn("Failed to set initial Realtime auth token:", h)),
        this.rest = new qk(new URL("rest/v1",a).href,{
            headers: this.headers,
            schema: c.db.schema,
            fetch: this.fetch
        }),
        this.storage = new FT(this.storageUrl.href,this.headers,this.fetch,n == null ? void 0 : n.storage),
        c.accessToken || this._listenForAuthEvents()
    }
    get functions() {
        return new Vk(this.functionsUrl.href,{
            headers: this.headers,
            customFetch: this.fetch
        })
    }
    from(e) {
        return this.rest.from(e)
    }
    schema(e) {
        return this.rest.schema(e)
    }
    rpc(e, r={}, n={
        head: !1,
        get: !1,
        count: void 0
    }) {
        return this.rest.rpc(e, r, n)
    }
    channel(e, r={
        config: {}
    }) {
        return this.realtime.channel(e, r)
    }
    getChannels() {
        return this.realtime.getChannels()
    }
    removeChannel(e) {
        return this.realtime.removeChannel(e)
    }
    removeAllChannels() {
        return this.realtime.removeAllChannels()
    }
    async _getAccessToken() {
        var e, r;
        if (this.accessToken)
            return await this.accessToken();
        const {data: n} = await this.auth.getSession();
        return (r = (e = n.session) === null || e === void 0 ? void 0 : e.access_token) !== null && r !== void 0 ? r : this.supabaseKey
    }
    _initSupabaseAuthClient({autoRefreshToken: e, persistSession: r, detectSessionInUrl: n, storage: s, userStorage: i, storageKey: o, flowType: a, lock: l, debug: u, throwOnError: c}, h, f) {
        const d = {
            Authorization: `Bearer ${this.supabaseKey}`,
            apikey: `${this.supabaseKey}`
        };
        return new iP({
            url: this.authUrl.href,
            headers: Object.assign(Object.assign({}, d), h),
            storageKey: o,
            autoRefreshToken: e,
            persistSession: r,
            detectSessionInUrl: n,
            storage: s,
            userStorage: i,
            flowType: a,
            lock: l,
            debug: u,
            throwOnError: c,
            fetch: f,
            hasCustomAuthorizationHeader: Object.keys(this.headers).some(y=>y.toLowerCase() === "authorization")
        })
    }
    _initRealtimeClient(e) {
        return new uT(this.realtimeUrl.href,Object.assign(Object.assign({}, e), {
            params: Object.assign({
                apikey: this.supabaseKey
            }, e == null ? void 0 : e.params)
        }))
    }
    _listenForAuthEvents() {
        return this.auth.onAuthStateChange((r,n)=>{
            this._handleTokenChanged(r, "CLIENT", n == null ? void 0 : n.access_token)
        }
        )
    }
    _handleTokenChanged(e, r, n) {
        (e === "TOKEN_REFRESHED" || e === "SIGNED_IN") && this.changedAccessToken !== n ? (this.changedAccessToken = n,
        this.realtime.setAuth(n)) : e === "SIGNED_OUT" && (this.realtime.setAuth(),
        r == "STORAGE" && this.auth.signOut(),
        this.changedAccessToken = void 0)
    }
}
const aP = (t,e,r)=>new oP(t,e,r);
function lP() {
    if (typeof window < "u" || typeof process > "u")
        return !1;
    const t = process.version;
    if (t == null)
        return !1;
    const e = t.match(/^v(\d+)\./);
    return e ? parseInt(e[1], 10) <= 18 : !1
}
lP() && console.warn("âš ï¸  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217");
const uP = "https://xoyslyiawgrtbjloajxo.supabase.co"
  , cP = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhveXNseWlhd2dydGJqbG9hanhvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ3NDAxMzMsImV4cCI6MjA4MDMxNjEzM30.SWY18LDfnnqZpvAJN-74mdj3wL3pfbvcTRJ26-_-PJ0"
  , dP = aP(uP, cP, {
    auth: {
        storage: localStorage,
        persistSession: !0,
        autoRefreshToken: !0
    }
})
  , Iy = b.memo(({emote: t, onSelect: e, isProcessing: r, variant: n})=>x.jsxs("button", {
    onClick: ()=>e(t.id),
    disabled: r,
    className: `px-2 py-2 text-xs font-medium rounded-lg border disabled:opacity-50 disabled:cursor-not-allowed active:opacity-80 ${n === "ob51" ? "bg-orange-600/80 border-orange-400/50 text-white" : "bg-purple-600/80 border-purple-400/50 text-white"}`,
    children: [x.jsx("img", {
        src: t.imageUrl,
        alt: "",
        className: "w-12 h-12 mx-auto mb-1 object-contain",
        loading: "lazy",
        decoding: "async"
    }), x.jsx("div", {
        className: `text-[10px] ${n === "ob51" ? "text-orange-200" : "text-purple-200"}`,
        children: t.id
    })]
}));
Iy.displayName = "EmoteButton";
const Tp = [{
    id: "909000001",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000001"
}, {
    id: "909000002",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000002"
}, {
    id: "909000003",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000003"
}, {
    id: "909000004",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000004"
}, {
    id: "909000005",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000005"
}, {
    id: "909000006",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000006"
}, {
    id: "909000007",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000007"
}, {
    id: "909000008",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000008"
}, {
    id: "909000009",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000009"
}, {
    id: "909000010",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000010"
}, {
    id: "909000011",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000011"
}, {
    id: "909000012",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000012"
}, {
    id: "909000013",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000013"
}, {
    id: "909000014",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000014"
}, {
    id: "909000015",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000015"
}, {
    id: "909000016",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000016"
}, {
    id: "909000017",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000017"
}, {
    id: "909000018",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000018"
}, {
    id: "909000019",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000019"
}, {
    id: "909000020",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000020"
}, {
    id: "909000021",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000021"
}, {
    id: "909000022",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000022"
}, {
    id: "909000023",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000023"
}, {
    id: "909000024",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000024"
}, {
    id: "909000025",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000025"
}, {
    id: "909000026",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000026"
}, {
    id: "909000027",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000027"
}, {
    id: "909000028",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000028"
}, {
    id: "909000029",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000029"
}, {
    id: "909000031",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000031"
}, {
    id: "909000032",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000032"
}, {
    id: "909000033",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000033"
}, {
    id: "909000034",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000034"
}, {
    id: "909000036",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000036"
}, {
    id: "909000037",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000037"
}, {
    id: "909000038",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000038"
}, {
    id: "909000039",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000039"
}, {
    id: "909000040",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000040"
}, {
    id: "909000041",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000041"
}, {
    id: "909000042",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000042"
}, {
    id: "909000043",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000043"
}, {
    id: "909000044",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000044"
}, {
    id: "909000045",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000045"
}, {
    id: "909000046",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000046"
}, {
    id: "909000047",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000047"
}, {
    id: "909000048",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000048"
}, {
    id: "909000049",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000049"
}, {
    id: "909000051",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000051"
}, {
    id: "909000052",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000052"
}, {
    id: "909000053",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000053"
}, {
    id: "909000054",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000054"
}, {
    id: "909000055",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000055"
}, {
    id: "909000056",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000056"
}, {
    id: "909000057",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000057"
}, {
    id: "909000058",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000058"
}, {
    id: "909000059",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000059"
}, {
    id: "909000060",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000060"
}, {
    id: "909000061",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000061"
}, {
    id: "909000062",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000062"
}, {
    id: "909000063",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000063"
}, {
    id: "909000064",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000064"
}, {
    id: "909000065",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000065"
}, {
    id: "909000066",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000066"
}, {
    id: "909000067",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000067"
}, {
    id: "909000068",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000068"
}, {
    id: "909000069",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000069"
}, {
    id: "909000070",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000070"
}, {
    id: "909000071",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000071"
}, {
    id: "909000072",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000072"
}, {
    id: "909000073",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000073"
}, {
    id: "909000074",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000074"
}, {
    id: "909000075",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000075"
}, {
    id: "909000076",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000076"
}, {
    id: "909000077",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000077"
}, {
    id: "909000078",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000078"
}, {
    id: "909000079",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000079"
}, {
    id: "909000080",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000080"
}, {
    id: "909000081",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000081"
}, {
    id: "909000082",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000082"
}, {
    id: "909000083",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000083"
}, {
    id: "909000084",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000084"
}, {
    id: "909000085",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000085"
}, {
    id: "909000086",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000086"
}, {
    id: "909000087",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000087"
}, {
    id: "909000088",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000088"
}, {
    id: "909000089",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000089"
}, {
    id: "909000090",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000090"
}, {
    id: "909000091",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000091"
}, {
    id: "909000092",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000092"
}, {
    id: "909000093",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000093"
}, {
    id: "909000094",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000094"
}, {
    id: "909000095",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000095"
}, {
    id: "909000096",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000096"
}, {
    id: "909000097",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000097"
}, {
    id: "909000098",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000098"
}, {
    id: "909000099",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000099"
}, {
    id: "909000121",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000121"
}, {
    id: "909000122",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000122"
}, {
    id: "909000123",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000123"
}, {
    id: "909000124",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000124"
}, {
    id: "909000125",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909000125"
}]
  , Cp = [{
    id: "909051001",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909051001"
}, {
    id: "909051002",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909051002"
}, {
    id: "909051003",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909051003"
}, {
    id: "909051004",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909051004"
}, {
    id: "909051005",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909051005"
}, {
    id: "909051006",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909051006"
}, {
    id: "909051007",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909051007"
}, {
    id: "909051008",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909051008"
}, {
    id: "909051009",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909051009"
}, {
    id: "909051010",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909051010"
}, {
    id: "909051011",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909051011"
}, {
    id: "909051012",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909051012"
}, {
    id: "909051013",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909051013"
}, {
    id: "909051014",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909051014"
}, {
    id: "909051015",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909051015"
}, {
    id: "909051016",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909051016"
}, {
    id: "909051017",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909051017"
}, {
    id: "909051018",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909051018"
}, {
    id: "909051019",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909051019"
}, {
    id: "909051020",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909051020"
}]
  , Fo = {
    id: "909042007",
    imageUrl: "https://godjexaremoteweb.vercel.app/image?itemid=909042007",
    name: "100lv"
}
  , hP = ({onSelectEmote: t, isProcessing: e})=>{
    const [r,n] = b.useState("all")
      , s = r === "all" ? Tp : Cp;
    return x.jsxs("div", {
        className: "space-y-4",
        children: [x.jsxs("div", {
            className: "mb-4",
            children: [x.jsxs("h3", {
                className: "text-sm font-bold text-yellow-400 uppercase tracking-wider flex items-center gap-2 mb-2",
                children: [x.jsx("span", {
                    className: "w-2 h-2 bg-yellow-400 rounded-full animate-pulse"
                }), "Special Emote"]
            }), x.jsxs("button", {
                onClick: ()=>t(Fo.id),
                disabled: e,
                className: "px-4 py-3 font-bold rounded-lg border disabled:opacity-50 disabled:cursor-not-allowed bg-yellow-500 border-yellow-400 text-white active:opacity-80",
                children: [x.jsx("img", {
                    src: Fo.imageUrl,
                    alt: "",
                    className: "w-16 h-16 mx-auto mb-2 object-contain"
                }), x.jsx("div", {
                    className: "text-sm font-bold text-yellow-100",
                    children: Fo.name
                }), x.jsx("div", {
                    className: "text-[10px] text-yellow-200/80",
                    children: Fo.id
                })]
            })]
        }), x.jsxs("div", {
            className: "flex gap-2 mb-4",
            children: [x.jsxs("button", {
                onClick: ()=>n("all"),
                className: `px-4 py-2 text-sm font-bold rounded-lg border ${r === "all" ? "bg-neon-cyan text-black border-neon-cyan" : "bg-card/50 text-muted-foreground border-border"}`,
                children: ["ALL (", Tp.length, ")"]
            }), x.jsxs("button", {
                onClick: ()=>n("ob51"),
                className: `px-4 py-2 text-sm font-bold rounded-lg border ${r === "ob51" ? "bg-orange-500 text-white border-orange-400" : "bg-card/50 text-muted-foreground border-border"}`,
                children: ["OB51 (", Cp.length, ")"]
            })]
        }), x.jsxs("h3", {
            className: "text-sm font-bold text-neon-cyan uppercase tracking-wider flex items-center gap-2",
            children: [x.jsx("span", {
                className: "w-2 h-2 bg-neon-cyan rounded-full animate-pulse"
            }), r === "all" ? "Emotes" : "OB51 Emotes", " (", s.length, ")"]
        }), x.jsx("div", {
            className: "grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-2",
            children: s.map(i=>x.jsx(Iy, {
                emote: i,
                onSelect: t,
                isProcessing: e,
                variant: r
            }, i.id))
        })]
    })
}
  , fP = b.memo(hP)
  , pP = ()=>{
    const [t,e] = b.useState("")
      , [r,n] = b.useState({
        uid1: "",
        uid2: "",
        uid3: "",
        uid4: "",
        uid5: "",
        uid6: ""
    })
      , [s,i] = b.useState("")
      , [o,a] = b.useState(!1)
      , l = (f,d)=>{
        n(y=>({
            ...y,
            [f]: d
        }))
    }
      , u = async f=>{
        if (!t.trim()) {
            Or({
                title: "Error",
                description: "Please enter Team Code",
                variant: "destructive"
            });
            return
        }
        if (!r.uid1.trim()) {
            Or({
                title: "Error",
                description: "Please enter at least UID1",
                variant: "destructive"
            });
            return
        }
        if (!f.trim()) {
            Or({
                title: "Error",
                description: "Please select or enter Emote ID",
                variant: "destructive"
            });
            return
        }
        a(!0);
        try {
            const {data: d, error: y} = await dP.functions.invoke("process-emote", {
                body: {
                    teamCode: t,
                    uid1: r.uid1,
                    uid2: r.uid2,
                    uid3: r.uid3,
                    uid4: r.uid4,
                    uid5: r.uid5,
                    uid6: r.uid6,
                    emoteId: f
                }
            });
            if (y)
                throw new Error(y.message);
            if (d != null && d.success)
                Or({
                    title: "Emote Sent! ðŸŽ‰",
                    description: "Your emote has been processed successfully!"
                }),
                console.log("API Response:", d);
            else
                throw new Error((d == null ? void 0 : d.error) || "Failed to process emote")
        } catch (d) {
            Or({
                title: "Error",
                description: d instanceof Error ? d.message : "Failed to process emote. Please try again.",
                variant: "destructive"
            }),
            console.error("API Error:", d)
        } finally {
            a(!1)
        }
    }
      , c = f=>{
        i(f),
        u(f)
    }
      , h = ()=>{
        u(s)
    }
    ;
    return x.jsxs("div", {
        className: "space-y-6",
        children: [x.jsxs("div", {
            className: "space-y-2",
            children: [x.jsxs("label", {
                className: "block text-sm font-bold text-neon-cyan uppercase tracking-wider flex items-center gap-2",
                children: [x.jsx("span", {
                    className: "w-2 h-2 bg-neon-cyan rounded-full animate-pulse"
                }), "Team Code"]
            }), x.jsx(vs, {
                type: "text",
                placeholder: "Enter Team Code",
                value: t,
                onChange: f=>e(f.target.value),
                className: "bg-card/50 border-neon-cyan/30 focus:border-neon-cyan"
            })]
        }), x.jsxs("div", {
            className: "space-y-4",
            children: [x.jsxs("h3", {
                className: "text-sm font-bold text-neon-purple uppercase tracking-wider flex items-center gap-2",
                children: [x.jsx("span", {
                    className: "w-2 h-2 bg-neon-purple rounded-full animate-pulse"
                }), "Player UIDs"]
            }), x.jsx("div", {
                className: "grid grid-cols-1 sm:grid-cols-2 gap-4",
                children: Object.entries(r).map(([f,d],y)=>x.jsxs("div", {
                    className: "space-y-1",
                    children: [x.jsxs("label", {
                        className: "text-xs text-muted-foreground uppercase",
                        children: [f.toUpperCase(), " ", y === 0 && x.jsx("span", {
                            className: "text-destructive",
                            children: "*"
                        })]
                    }), x.jsx(vs, {
                        type: "text",
                        placeholder: `Enter ${f.toUpperCase()}`,
                        value: d,
                        onChange: m=>l(f, m.target.value),
                        className: "bg-card/50 border-neon-purple/30 focus:border-neon-purple"
                    })]
                }, f))
            })]
        }), x.jsx(fP, {
            onSelectEmote: c,
            isProcessing: o
        }), x.jsxs("div", {
            className: "space-y-2",
            children: [x.jsxs("label", {
                className: "block text-sm font-bold text-neon-pink uppercase tracking-wider flex items-center gap-2",
                children: [x.jsx("span", {
                    className: "w-2 h-2 bg-neon-pink rounded-full animate-pulse"
                }), "Or Enter Emote ID Manually"]
            }), x.jsx(vs, {
                type: "text",
                placeholder: "Enter Emote ID",
                value: s,
                onChange: f=>i(f.target.value),
                className: "bg-card/50 border-neon-pink/30 focus:border-neon-pink"
            })]
        }), x.jsx(Vd, {
            onClick: h,
            variant: "neon",
            size: "xl",
            className: "w-full mt-8",
            disabled: o,
            children: o ? x.jsxs("span", {
                className: "flex items-center gap-2",
                children: [x.jsxs("svg", {
                    className: "animate-spin h-5 w-5",
                    viewBox: "0 0 24 24",
                    children: [x.jsx("circle", {
                        className: "opacity-25",
                        cx: "12",
                        cy: "12",
                        r: "10",
                        stroke: "currentColor",
                        strokeWidth: "4",
                        fill: "none"
                    }), x.jsx("path", {
                        className: "opacity-75",
                        fill: "currentColor",
                        d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                    })]
                }), "Processing Emote..."]
            }) : x.jsxs(x.Fragment, {
                children: [x.jsx("span", {
                    children: "ðŸŽ®"
                }), "PROCESS EMOTE", x.jsx("span", {
                    children: "ðŸŽ®"
                })]
            })
        })]
    })
}
  , mP = ()=>{
    const [t,e] = b.useState(!1);
    return x.jsxs("div", {
        className: "min-h-screen py-8 px-4",
        children: [x.jsxs("div", {
            className: "fixed inset-0 overflow-hidden pointer-events-none",
            children: [x.jsx("div", {
                className: "absolute top-1/4 left-1/4 w-64 h-64 bg-neon-cyan/10 rounded-full blur-3xl animate-pulse"
            }), x.jsx("div", {
                className: "absolute bottom-1/4 right-1/4 w-96 h-96 bg-neon-purple/10 rounded-full blur-3xl animate-pulse",
                style: {
                    animationDelay: "1s"
                }
            }), x.jsx("div", {
                className: "absolute top-1/2 left-1/2 w-48 h-48 bg-neon-pink/10 rounded-full blur-3xl animate-pulse",
                style: {
                    animationDelay: "2s"
                }
            })]
        }), x.jsxs("div", {
            className: "relative z-10 max-w-lg mx-auto",
            children: [x.jsx(Nk, {
                className: "mb-8"
            }), x.jsx("div", {
                className: "glass-card rounded-2xl p-6 md:p-8 neon-border animate-border",
                children: t ? x.jsxs(x.Fragment, {
                    children: [x.jsxs("h2", {
                        className: "text-xl font-orbitron font-bold text-center text-foreground mb-6",
                        children: [x.jsx("span", {
                            className: "text-neon-green animate-pulse",
                            children: "â—"
                        }), " EMOTE PANEL"]
                    }), x.jsx(pP, {})]
                }) : x.jsxs(x.Fragment, {
                    children: [x.jsxs("h2", {
                        className: "text-xl font-orbitron font-bold text-center text-foreground mb-6",
                        children: [x.jsx("span", {
                            className: "text-neon-green",
                            children: "â—"
                        }), " LOGIN TO CONTINUE"]
                    }), x.jsx(Lk, {
                        onLogin: ()=>e(!0)
                    })]
                })
            }), x.jsxs("div", {
                className: "mt-8",
                children: [x.jsx("p", {
                    className: "text-center text-muted-foreground text-sm mb-4 uppercase tracking-wider",
                    children: "Follow Us"
                }), x.jsx(Ik, {})]
            }), x.jsx("footer", {
                className: "mt-12 text-center",
                children: x.jsxs("p", {
                    className: "text-xs text-muted-foreground",
                    children: ["Â© 2024 ", x.jsx("span", {
                        className: "text-neon-cyan",
                        children: "ANANT EMOTE WEB"
                    }), " | All Rights Reserved"]
                })
            })]
        })]
    })
}
  , gP = b.lazy(()=>y_(()=>import("./NotFound-ByT-zV6z.js"), []))
  , vP = new WS
  , yP = ()=>x.jsx(qS, {
    client: vP,
    children: x.jsxs(bS, {
        children: [x.jsx(n1, {}), x.jsx($1, {}), x.jsx(Ak, {
            children: x.jsxs(Ok, {
                children: [x.jsx(gc, {
                    path: "/",
                    element: x.jsx(mP, {})
                }), x.jsx(gc, {
                    path: "*",
                    element: x.jsx(b.Suspense, {
                        fallback: x.jsx("div", {
                            children: "Loading..."
                        }),
                        children: x.jsx(gP, {})
                    })
                })]
            })
        })]
    })
});
X0(document.getElementById("root")).render(x.jsx(yP, {}));
export {x as j, b as r, mk as u};
